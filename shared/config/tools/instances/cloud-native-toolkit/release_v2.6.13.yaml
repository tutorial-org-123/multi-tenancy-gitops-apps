apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-gitops-edge-v2-6-13
  annotations:
    description: Registers the image with the Edge server using the hzn cli
    app.openshift.io/description: Registers the image with the Edge server using the hzn cli
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: image-url
      default: ""
    - name: service-name
      default: ""
    - name: version
      default: ""
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  volumes:
    - name: source
      emptyDir: {}
    - name: icp-ca
      secret:
        secretName: edge-access
        items:
          - key: HZN_CERTIFICATE
            path: icp-ca.crt
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: gitops-edge
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      securityContext:
        allowPrivilegeEscalation : true
      env:
        - name: HOME
          value: /home/devops
        - name: HZN_EXCHANGE_URL
          valueFrom:
            secretKeyRef:
              name: edge-access
              key: HZN_EXCHANGE_URL
              optional: true
        - name: HZN_ORG_ID
          valueFrom:
            secretKeyRef:
              name: edge-access
              key: HZN_ORG_ID
              optional: true
        - name: HZN_EXCHANGE_USER_AUTH
          valueFrom:
            secretKeyRef:
              name: edge-access
              key: HZN_EXCHANGE_USER_AUTH
              optional: true
        - name: HZN_CERTIFICATE
          valueFrom:
            secretKeyRef:
              name: edge-access
              key: HZN_CERTIFICATE
              optional: true
      volumeMounts:
        - mountPath: /opt/certs
          name: icp-ca
      script: |
          #!/usr/bin/env bash
          set -ex

          if [[ -z "${HZN_EXCHANGE_URL}" ]]; then
            echo "Edge Exchange has not been configured. Skipping trigger step"
            exit 0
          fi

          SERVICE_NAME="$(params.service-name)"
          VERSION="$(params.version)"
          REGISTRY_SERVER_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $1}')
          REGISTRY_NAMESPACE_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $2}')
          REGISTRY_REPOSITORY_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $3}')
          REGISTRY_TAG_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $3}' | awk -F : '{print $2}')
          BASE_IMAGE="${REGISTRY_SERVER_VALUE}/${REGISTRY_NAMESPACE_VALUE}"

          if [[ -z "${SERVICE_NAME}" ]]; then
            # if service name not passed explicit assume to use image repository
            SERVICE_NAME="${REGISTRY_REPOSITORY_VALUE}"
          fi

          if [[ -z "${VERSION}" ]]; then
            # if version not passed explicit assume to use image tag
            VERSION="${REGISTRY_TAG_VALUE}"
          fi

          if [[ -z "${SERVICE_NAME}" ]] || [[ -z "${VERSION}" ]] || [[ -z "${BASE_IMAGE}" ]] || [[ "${BASE_IMAGE}" = "/" ]]; then
            echo "Edge Service, Version, or Base image parameters missing"
            exit 1
          fi

          if [[ -z "${HZN_EXCHANGE_USER_AUTH}" ]] || [[ -z "${HZN_CERTIFICATE}" ]]; then
            echo "Edge Credentials or Certificate not set"
            exit 1
          fi

          set +x
          if [[ -z "${HZN_EXCHANGE_USER_AUTH}" ]] || [[ -z "${HZN_CERTIFICATE}" ]]; then
            echo "Edge Credentials or Certificate not set"
            exit 1
          fi
          set -x



          hzn version

          # Verify the Edge Cert is visible from the Tekton Task
          ls /opt/certs/*.crt

          cp /opt/certs/icp-ca.crt /usr/local/share/ca-certificates && update-ca-certificates

          mkdir -p ./horizon

          cat <<JSON >./horizon/hzn.json
          {
            "HZN_ORG_ID": "${HZN_ORG_ID}",
            "MetadataVars": {
              "DOCKER_IMAGE_BASE": "${BASE_IMAGE}",
              "SERVICE_NAME": "${SERVICE_NAME}",
              "SERVICE_VERSION": "${VERSION}"
            }
          }
          JSON

          cat ./horizon/hzn.json

          # Publish Service to Edge Application Manager
          hzn key create "IBM" "user@us.ibm.com"

          make publish-service

          echo "Edge Service registered"

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-operator-bundle-v2-6-13
  annotations:
    description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: image-url
      default: ""
    - name: image-suffix
      default: "-bundle"
    - name: image-tag
      default: ""
    - name: default-channel
      default: "alpha"
    - name: BUNDLE_IMAGE
      default: quay.io/ibmgaragecloud/operator-sdk:v0.10.4
    - name: BUILDER_IMAGE
      default: quay.io/buildah/stable:v1.15.0
    - name: DOCKERFILE
      default: ./bundle.Dockerfile
    - name: CONTEXT
      default: .
    - name: TLSVERIFY
      default: "false"
    - name: FORMAT
      default: "docker"
    - name: STORAGE_DRIVER
      description: Set buildah storage driver
      default: overlay
  results:
    - name: bundle-image-url
  volumes:
    - name: varlibcontainers
      emptyDir: {}
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: build
      image: $(params.BUNDLE_IMAGE)
      workingDir: $(params.source-dir)
      env:
        - name: REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_USER
              optional: true
        - name: REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_PASSWORD
              optional: true
      volumeMounts:
        - mountPath: /var/lib/containers
          name: varlibcontainers
      securityContext:
        privileged: true
      script: |
        export VERSION="$(params.image-tag)"
        export IMG="$(params.image-url):$(params.image-tag)"
        export BUNDLE_IMG_BASE="$(params.image-url)$(params.image-suffix)"
        export BUNDLE_IMG="${BUNDLE_IMG_BASE}:$(params.image-tag)"

        IMAGE_SERVER=$(echo "${BUNDLE_IMG}" | awk -F / '{print $1}')

        make bundle

        # TODO missing default channel
        echo "LABEL operators.operatorframework.io.bundle.channel.default.v1=$(params.default-channel)" >> $(params.DOCKERFILE)
        cat $(params.DOCKERFILE)
        echo "  operators.operatorframework.io.bundle.channel.default.v1: $(params.default-channel)" >> bundle/metadata/annotations.yaml
        cat bundle/metadata/annotations.yaml

        podman --storage-driver=$(params.STORAGE_DRIVER) build --format=$(params.FORMAT) --tls-verify=$(params.TLSVERIFY) -f $(params.DOCKERFILE) -t ${BUNDLE_IMG} $(params.CONTEXT)
        set +x
        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ "${IMAGE_SERVER}" != "image-registry.openshift-image-registry.svc:5000"  ]]; then
          podman login -u "${REGISTRY_USER}" -p "${REGISTRY_PASSWORD}" "${IMAGE_SERVER}"
          echo "podman login -u "${REGISTRY_USER}" -p "xxxxx" "${IMAGE_SERVER}""
        fi
        set -x
        podman --storage-driver=$(params.STORAGE_DRIVER) push --tls-verify=$(params.TLSVERIFY) --digestfile ./image-digest ${BUNDLE_IMG} docker://${BUNDLE_IMG}

        echo -n "${BUNDLE_IMG_BASE}" > $(results.bundle-image-url.path)

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-gradle-pact-verify-v2-6-13
  annotations:
    description: Performs pact verification on the service provider
    app.openshift.io/description: Performs pact verification on the service provider
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: service-protocol
      default: "http"
    - name: service-host
    - name: service-port
      default: "80"
    - name: gradle-image
      default: quay.io/ibmgaragecloud/gradle:jdk11
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: pact-verify
      image: $(params.gradle-image)
      workingDir: $(params.source-dir)
      env:
        - name: GRADLE_USER_HOME
          value: $(params.source-dir)
        - name: PACTBROKER_URL
          valueFrom:
            secretKeyRef:
              name: pactbroker-access
              key: PACTBROKER_URL
              optional: true
        - name: PACTBROKER_USER
          valueFrom:
            secretKeyRef:
              name: pactbroker-access
              key: PACTBROKER_USER
              optional: true
        - name: PACTBROKER_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pactbroker-access
              key: PACTBROKER_PASSWORD
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex

          if [[ -z "${PACTBROKER_URL}" ]]; then
            echo "PactBroker url not set. Skipping pact verification"
            exit 0
          fi

          if ./gradlew tasks --all | grep -Eq "^pactVerify"; then
              echo "Pact Verify task found"
          else
              echo "Skipping Pact Verify step, no task defined"
              exit 0
          fi

          PROTOCOL=$(params.service-protocol)
          HOST=$(params.service-host)
          PORT=$(params.service-port)

          ./gradlew pactVerify \
            -PpactBrokerUrl=${PACTBROKER_URL} \
            -PpactProtocol=${PROTOCOL} \
            -PpactHost=${HOST} \
            -PpactPort=${PORT} \
            -Ppact.verifier.publishResults=true

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-health-check-mq-v2-6-13
  annotations:
    description: Performs a health check on the queue manager
    app.openshift.io/description: Performs a health check on the queue manager
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: app-namespace
      default: ""
    - name: app-name
      default: ""
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  steps:
    - name: health-check
      image: $(params.tools-image)
      script: |
          #!/usr/bin/env bash
          set -x

          APP_NAME="$(params.app-name)"

          # RELEASE_NAME="${APP_NAME}"
          RELEASE_NAME="qm-dev"
          echo "RELEASE_NAME: $RELEASE_NAME"

          podname=$(kubectl get pods --selector=app.kubernetes.io/instance=$RELEASE_NAME -o custom-columns=POD:.metadata.name --no-headers | head -n 1)
          echo "podname: $podname"

          queue="QM1"
          echo "queue name: $queue"

          echo "Sleep before test to make sure QMGR is up"
          sleep 20

          echo "Print the queue details: ..."
          echo ""
          kubectl exec $podname -- /bin/bash -c "echo \"define qlocal($queue) replace\" | runmqsc "

          echo "Print the queue details: ..."
          echo ""
          kubectl exec $podname -- /bin/bash -c "echo \"DISPLAY QL($queue) ALL\" | runmqsc" > checkQ.txt 2>&1
          cat checkQ.txt

          if grep -q "QUEUE($queue)" checkQ.txt; then
            echo "Queue has been successfully created."
          else
            exit 1
          fi

          # put message on queue
          kubectl exec $podname -- /bin/bash -c "echo \"hello-world\" | /opt/mqm/samp/bin/amqsput $queue" > putMessage.txt 2>&1
          cat putMessage.txt
          echo "----------"
          fail="reason code"
          if grep -q "$fail" putMessage.txt; then
            exit 1
          else
            echo "Message has been successfully put the queue."
          fi

          # get message on queue
          kubectl exec $podname  -c qmgr -- /opt/mqm/samp/bin/amqsget $queue > getMessage.txt 2>&1
          cat getMessage.txt
          if grep -q "hello-world" getMessage.txt; then
              echo "Message has been found on the queue."
          else
              echo "Error: Message has not been retrieved from the queue."
              exit 1
          fi

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-build-tag-push-v2-6-13
  annotations:
    description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: image-server
      default: ""
    - name: image-namespace
      default: ""
    - name: image-repository
      default: ""
    - name: image-tag
      default: ""
    - name: BUILDER_IMAGE
      default: quay.io/buildah/stable:v1.15.0
    - name: DOCKERFILE
      default: ./Dockerfile
    - name: CONTEXT
      default: .
    - name: TLSVERIFY
      default: "false"
    - name: FORMAT
      default: "docker"
    - name: STORAGE_DRIVER
      description: Set buildah storage driver
      default: overlay
  volumes:
    - name: varlibcontainers
      emptyDir: {}
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: build
      image: $(params.BUILDER_IMAGE)
      workingDir: $(params.source-dir)
      env:
        - name: REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_USER
              optional: true
        - name: REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_PASSWORD
              optional: true
        - name: IBM_ENTITLED_REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: ibm-entitled-registry-credentials
              key: IBM_ENTITLED_REGISTRY_USER
              optional: true
        - name: IBM_ENTITLED_REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: ibm-entitled-registry-credentials
              key: IBM_ENTITLED_REGISTRY_PASSWORD
              optional: true
      volumeMounts:
        - mountPath: /var/lib/containers
          name: varlibcontainers
      securityContext:
        privileged: true
      script: |
        APP_IMAGE="$(params.image-server)/$(params.image-namespace)/$(params.image-repository):$(params.image-tag)"
        if [[ -n "${IBM_ENTITLED_REGISTRY_USER}" ]] && [[ -n "${IBM_ENTITLED_REGISTRY_PASSWORD}" ]]; then
          buildah login -u ${IBM_ENTITLED_REGISTRY_USER} -p ${IBM_ENTITLED_REGISTRY_PASSWORD} cp.icr.io
          echo "buildah login -u "${IBM_ENTITLED_REGISTRY_USER}" -p "xxxxx" cp.icr.io"
        fi
        buildah --layers --storage-driver=$(params.STORAGE_DRIVER) bud --format=$(params.FORMAT) --tls-verify=$(params.TLSVERIFY) -f $(params.DOCKERFILE) -t ${APP_IMAGE} $(params.CONTEXT)
        set +x
        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ "$(params.image-server)" != "image-registry.openshift-image-registry.svc:5000"  ]]; then
          buildah login -u "${REGISTRY_USER}" -p "${REGISTRY_PASSWORD}" "$(params.image-server)"
          echo "buildah login -u "${REGISTRY_USER}" -p "xxxxx" "$(params.image-server)""
        fi
        set -x
        buildah --storage-driver=$(params.STORAGE_DRIVER) push --tls-verify=$(params.TLSVERIFY) --digestfile ./image-digest ${APP_IMAGE} docker://${APP_IMAGE}

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-dockerfile-lint-v2-6-13
  annotations:
    description: Optional linter for Dockerfiles; if a ".hadolint" file is in the repo root, this task automatically picks up; otherwise hadolint file name must be passed via ConfigMap. See Hadolint on Dockerhub for more
    app.openshift.io/description: Optional linter for Dockerfiles; if a ".hadolint" file is in the repo root, this task automatically picks up; otherwise hadolint file name must be passed via ConfigMap
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: DOCKERFILE
      default: Dockerfile
    - name: CONTEXT
      default: .
    - name: LINT_IMAGE
      default: ghcr.io/hadolint/hadolint:v2.3.0-alpine
    - name: lint-dockerfile
      default: "true"

  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: alpine/git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: lint
      image: $(params.LINT_IMAGE)
      workingDir: $(params.source-dir)
      env:
        - name: HADOLINT_CFG
          valueFrom:
            configMapKeyRef:
              name: hadolint-config
              key: HADOLINT_CFG
              optional: true
      script: |
        PERFORM_LINT="$(params.lint-dockerfile)"
        if [[ "${PERFORM_LINT}" == "false" ]] || [[ -z "${PERFORM_LINT}" ]]; then
          echo "User selected to skip Dockerfile linting. Skipping this task."
          exit 0
        fi

        FILE="$(params.source-dir)"/.hadolint.yaml

        if [ -f "${HADOLINT_CFG}" ]; then
          FILE="$(params.source-dir)/${HADOLINT_CFG}"
          echo "In this step, hadolint will lint your Dockerfile, using ${FILE}, with the following rules: "
          cat ${FILE}
          echo "For more information about hadolint please refer to https://cloudnativetoolkit.dev/"
          hadolint --config ${HADOLINT_CFG} $(params.DOCKERFILE)

        elif [ -f "${FILE}" ]; then
          echo "In this step, hadolint will lint your Dockerfile, using .hadolint.yaml in your repository, with the following rules: "
          cat "${FILE}"
          echo "For more information about hadolint please refer to https://cloudnativetoolkit.dev/"
          hadolint $(params.DOCKERFILE)

        else
          echo "In this step, hadolint will lint your Dockerfile"
          echo "If you would like to configure hadolint, please see https://github.com/hadolint/hadolint"
          echo "For more information about hadolint please refer to https://cloudnativetoolkit.dev/"
          hadolint $(params.DOCKERFILE)
        fi

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-operator-catalog-gitops-v2-6-13
  annotations:
    description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: app-name
      default: ""
    - name: source-dir
      default: /source
    - name: gitops-dir
      default: /gitops
    - name: subdir
      default: ""
    - name: parentdir
      default: ""
    - name: deploy-dir
      default: deploy
    - name: image-url
      default: ""
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  volumes:
    - name: source
      emptyDir: {}
    - name: gitops
      emptyDir: { }
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
      - name: gitops
        mountPath: $(params.gitops-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: gitops
      image: $(params.tools-image)
      workingDir: $(params.gitops-dir)
      env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: HOME
          value: /home/devops
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME_CD
          valueFrom:
            secretKeyRef:
              name: gitops-cd-secret
              key: username
              optional: true
        - name: GIT_PASSWORD_CD
          valueFrom:
            secretKeyRef:
              name: gitops-cd-secret
              key: password
              optional: true
        - name: GIT_PARENT_DIR
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: parentdir
              optional: true
        - name: GIT_PROTOCOL
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: protocol
              optional: true
        - name: GIT_HOST
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: host
              optional: true
        - name: GIT_ORG
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: org
              optional: true
        - name: GIT_REPO
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: repo
              optional: true
        - name: GIT_BRANCH
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: branch
              optional: true
      script: |
        #!/usr/bin/env bash
        set -ex

        APP_NAME="$(params.app-name)"
        SUBDIR="$(params.subdir)"
        if [[ -z "${SUBDIR}" ]]; then
          SUBDIR="${APP_NAME}"
        fi
        if [[ -n "$(params.parentdir)" ]]; then
          PARENT_DIR="$(params.parentdir)"
        elif [[ -n "${GIT_PARENT_DIR}" ]] && [[ "${GIT_PARENT_DIR}" = "bash -c"* ]]; then
          PARENT_DIR=$(eval $GIT_PARENT_DIR | tail -n 1)
        elif [[ -n "${GIT_PARENT_DIR}" ]]; then
          PARENT_DIR="${GIT_PARENT_DIR}"
        else
          PARENT_DIR="."
        fi
        SUBDIR="${PARENT_DIR}/${SUBDIR}"

        PROTOCOL="${GIT_PROTOCOL}"
        if [[ -z "${PROTOCOL}" ]]; then
          PROTOCOL="https"
        fi


        BUNDLE_URL="$(params.image-url)"

        if [[ -z "${GIT_HOST}" ]] || [[ -z "${GIT_ORG}" ]] || [[ -z "${GIT_REPO}" ]]; then
            echo "GitOps repo has not been configured with confimap gitops-repo. Skipping trigger step"
            exit 0
        fi

        set +x
        if [[ -n "${GIT_USERNAME_CD}" ]]; then
          GIT_AUTH_USER="${GIT_USERNAME_CD}"
          GIT_AUTH_PWD="${GIT_PASSWORD_CD}"
        elif [[ -n "${GIT_USERNAME}" ]]; then
          GIT_AUTH_USER="${GIT_USERNAME}"
          GIT_AUTH_PWD="${GIT_PASSWORD}"
        else
          echo "Credentials for GitOps repo not set in secret gitops-cd-secret or git-credentials"
          exit 1
        fi
        set -x

        BRANCH_CMD=""
        if [[ -n "${GIT_BRANCH}" ]]; then
          BRANCH_CMD="-b ${GIT_BRANCH}"
        fi

        git config --global user.email "gitops@cloudnativetoolkit.dev"
        git config --global user.name "Cloud Native Toolkit Pipeline"
        echo "git clone ${BRANCH_CMD} ${PROTOCOL}://${GIT_AUTH_USER}:xxxx@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
        set +x
        GIT_URL="${PROTOCOL}://${GIT_AUTH_USER}:${GIT_AUTH_PWD}@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
        git clone ${BRANCH_CMD} ${GIT_URL} $(params.gitops-dir)
        set -x
        cd $(params.gitops-dir)

        mkdir -p ${SUBDIR}
        if [[ -d $(params.source-dir)/$(params.deploy-dir) ]] && grep -q CatalogSource $(params.source-dir)/$(params.deploy-dir)/*; then
          echo "Copying files from $(params.deploy-dir)/ into the GitOps repo ${SUBDIR}/"
          # Copy any non-CatalogSource files
          grep -L CatalogSource $(params.source-dir)/$(params.deploy-dir)/* | while read file; do
            dest_file=$(basename ${file})

            echo "Copying ${file} to ${SUBDIR}/${dest_file}"
            cp "${file}" ${SUBDIR}/${dest_file}
          done
          # Copy the CatalogSource and replace the image with the BUNDLE_URL
          grep -l CatalogSource $(params.source-dir)/$(params.deploy-dir)/* | while read file; do
            dest_file=$(basename ${file})

            echo "Copying ${file} to ${SUBDIR}/${dest_file}"
            cat "${file}" | sed -E "s~([ ]+image: ).*~\1${BUNDLE_URL}~g" > ${SUBDIR}/${dest_file}
          done
        else
          echo "Generating catalog-source.yaml"
          cat > ${SUBDIR}/catalog-source.yaml << EOF
        apiVersion: operators.coreos.com/v1alpha1
        kind: CatalogSource
        metadata:
          name: ${APP_NAME}
        spec:
          sourceType: grpc
          image: ${BUNDLE_URL}
          displayName: ${APP_NAME}
          publisher: grpc
        EOF

          echo "CatalogSource generated"
          cat ${SUBDIR}/catalog-source.yaml
        fi

        if [[ $(git status -s | wc -l) -eq 0 ]]; then
          echo "No changes"
          exit 0
        fi

        git add "${SUBDIR}/"
        git commit -m "Updates ${APP_NAME}"
        git push -v

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-img-scan-trivy-v2-6-13
  annotations:
    description: Runs an image scan with Trivy and fails the build if issues are found.
    app.openshift.io/description: Runs an image scan with Trivy and fails the build if issues are found.
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: image-url
      description: "The location of image to scan on IBM Container Registry <server>/<namespace>/<repository>:<tag>"
    - name: scan-image
      description: Flag indicating that a scan should be performed
      default: "false"
    - name: SKOPEO_IMAGE
      default: quay.io/containers/skopeo:v1.1.0
    - name: IMAGE_FROM_TLS_VERIFY
      default: "false"
    - name: TRIVY_IMAGE
      default: quay.io/ibmgaragecloud/aquasec-trivy
  volumes:
    - name: oci-image
      emptyDir: {}
  steps:
    - name: pull-image
      image: $(params.SKOPEO_IMAGE)
      env:
        - name: REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_USER
              optional: true
        - name: REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_PASSWORD
              optional: true
      volumeMounts:
        - mountPath: /var/oci
          name: oci-image
      securityContext:
        privileged: true
      script: |
        PERFORM_SCAN="$(params.scan-image)"
        if [[ "${PERFORM_SCAN}" == "false" ]] || [[ -z "${PERFORM_SCAN}" ]]; then
          echo "User selected to skip scanning. Skipping Trivy scan."
          exit 0
        fi
        IMAGE_FROM=$(params.image-url)
        REGISTRY_SERVER_FROM=$(echo "${IMAGE_FROM}" | awk -F / '{print $1}')
        IMAGE_TO="oci:/var/oci/image"
        IMAGE_FROM_TLS_VERIFY=$(params.IMAGE_FROM_TLS_VERIFY)
        echo "Tagging ${IMAGE_FROM} as ${IMAGE_TO}"
        set +x
        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ "${REGISTRY_SERVER_FROM}" != "image-registry.openshift-image-registry.svc:5000" ]]; then
          IMAGE_FROM_CREDS="--src-creds ${REGISTRY_USER}:${REGISTRY_PASSWORD}"
        fi
        set -x
        if [ "${REGISTRY_SERVER_FROM}" =~ ":" ]; then
          IMAGE_FROM_TLS_VERIFY="false"
        fi
        echo "skopeo copy --src-creds=xxxx --src-tls-verify=${IMAGE_FROM_TLS_VERIFY} docker://${IMAGE_FROM} ${IMAGE_TO}"
        set +x
        skopeo copy ${IMAGE_FROM_CREDS} --src-tls-verify=${IMAGE_FROM_TLS_VERIFY} docker://${IMAGE_FROM} ${IMAGE_TO}
    - name: scan-image
      image: $(params.TRIVY_IMAGE)
      volumeMounts:
        - mountPath: /var/oci
          name: oci-image
      script: |
          set -e
          PERFORM_SCAN="$(params.scan-image)"
          if [[ "${PERFORM_SCAN}" == "false" ]] || [[ -z "${PERFORM_SCAN}" ]]; then
            echo "User selected to skip scanning. Skipping Trivy scan."
            exit 0
          fi
          PATH_TO_IMAGE="/var/oci/image"
          echo -e "Trivy Security Scan image in registry"
          trivy image --exit-code 0 --input ${PATH_TO_IMAGE}
          trivy image --exit-code 1 --severity CRITICAL --input ${PATH_TO_IMAGE}
          my_exit_code=$?
          echo "Scan exit code :--- $my_exit_code"
          if [ ${my_exit_code} == 1 ]; then
              echo "Trivy scanning completed. CRITICAL Vulnerabilities found."
              exit 1
          else
            echo "Trivy scanning completed. CRITICAL vulnerabilities not found."
          fi

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-health-check-v2-6-13
  annotations:
    description: Performs a health check on the deployed application
    app.openshift.io/description: Performs a health check on the deployed application
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: app-namespace
      default: ""
    - name: app-name
      default: ""
    - name: deploy-ingress-type
      default: "route"
    - name: health-protocol
      default: "https"
    - name: health-endpoint
      default: "/health"
    - name: health-url
      default: ""
    - name: health-curl
      default: "-k"
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
    - name: resource-type
      default: ""
  steps:
    - name: health-check
      image: $(params.tools-image)
      script: |
          #!/usr/bin/env bash
          set -x

          URL="$(params.health-url)"
          CURL_FLAGS="$(params.health-curl)"

          if [[ -z "${URL}" ]]; then
            APP_NAMESPACE="$(params.app-namespace)"
            APP_NAME="$(params.app-name)"
            PROTOCOL="$(params.health-protocol)"
            INGRESS_TYPE="$(params.deploy-ingress-type)"
            HEALTH_ENDPOINT="$(params.health-endpoint)"

            echo "resource-type: $(params.resource-type)"

            if [[ "$(params.resource-type)" == *"integrationserver"* ]]; then
                HOST=$(kubectl get route/${APP_NAME}-${PROTOCOL} --namespace ${APP_NAMESPACE} --output=jsonpath='{ .spec.host }')
                if [[ -z "${PROTOCOL}" ]]; then
                  PROTOCOL="https"
                fi
            elif [[ "${INGRESS_TYPE}" == "route" ]]; then
                HOST=$(kubectl get route/${APP_NAME} --namespace ${APP_NAMESPACE} --output=jsonpath='{ .spec.host }')
                if [[ -z "${PROTOCOL}" ]]; then
                  PROTOCOL="https"
                fi
            else
                HOST=$(kubectl get ingress/${APP_NAME} --namespace ${APP_NAMESPACE} --output=jsonpath='{ .spec.rules[0].host }')
                if [[ -z "${PROTOCOL}" ]]; then
                  PROTOCOL="http"
                fi
            fi

            URL="${PROTOCOL}://${HOST}${HEALTH_ENDPOINT}"

          fi

          sleep_countdown=5
          # sleep for 10 seconds to allow enough time for the server to start
          sleep 10
          echo "Health check start"
          while [[ $(curl ${CURL_FLAGS} -sL -w "%{http_code}\\n" "${URL}" -o /dev/null --connect-timeout 3 --max-time 5 --retry 3 --retry-max-time 30) != "200" ]]; do
              sleep 30
              echo "Health check failure. Remaining retries: $sleep_countdown"
              sleep_countdown=$((sleep_countdown-1))
              if [[ $sleep_countdown -eq 0 ]]; then
                      echo "Could not reach health endpoint: ${URL}"
                      exit 1;
              fi
          done
          echo "Successfully reached health endpoint: ${URL}"
          echo "====================================================================="

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-smoke-tests-mq-v2-6-13
  annotations:
    description: Deploys the application to the CI environment for verification using the provided helm chart
    app.openshift.io/description: Deploys the application to the CI environment for verification using the provided helm chart
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: image-server
      default: ""
    - name: image-namespace
      default: ""
    - name: image-repository
      default: ""
    - name: image-tag
      default: ""
    - name: app-namespace
      default: ""
    - name: app-name
      default: ""
    - name: deploy-ingress-type
      default: "route"
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  results:
    - name: service-port
    - name: resource-type
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: deploy
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: TLS_SECRET_NAME
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: TLS_SECRET_NAME
              optional: true
        - name: INGRESS_SUBDOMAIN
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: INGRESS_SUBDOMAIN
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex
          GIT_URL="$(params.git-url)"
          GIT_REVISION="$(params.git-revision)"
          APP_NAMESPACE="$(params.app-namespace)"
          APP_NAME="$(params.app-name)"
          if [[ -z "${APP_NAME}" ]]; then
            APP_NAME="$(params.image-repository)"
          fi
          IMAGE_SERVER="$(params.image-server)"
          IMAGE_NAMESPACE="$(params.image-namespace)"
          IMAGE_REPOSITORY="$(params.image-repository)"
          IMAGE_VERSION="$(params.image-tag)"
          IMAGE_URL="${IMAGE_SERVER}/${IMAGE_NAMESPACE}/${IMAGE_REPOSITORY}"
          INGRESS_TYPE="$(params.deploy-ingress-type)"
          if [[ "${INGRESS_TYPE}" == "route" ]]; then
            ROUTE_ENABLED="true"
            INGRESS_ENABLED="false"
          else
            ROUTE_ENABLED="false"
            INGRESS_ENABLED="true"
          fi

          export CHART_ROOT=$(find . -name chart)
          echo "CHART_ROOT: $CHART_ROOT"

          FILE_NUM=$(find . -name 'Chart*.yaml' |wc -l)
          if [[ "${FILE_NUM}" -gt 1 ]]; then
            echo "Error: Found >1 Chart*.yaml"
            exit 1
          fi

          export CHART=$(find . -name 'Chart*.yaml')
          echo "CHART: $CHART"

          export CHART_NAME=$(cat $CHART | yq r - name)
          echo "CHART_NAME: $CHART_NAME"

          # Update Chart name and version
          if [[ "${CHART_NAME}" != "${APP_NAME}" ]]; then
            echo "Renaming chart from ${CHART_NAME} to ${APP_NAME}"
            cp -R "${CHART_ROOT}/${CHART_NAME}" "${CHART_ROOT}/${APP_NAME}"
            cat "${CHART_ROOT}/${CHART_NAME}/Chart.yaml" | \
                yq w - name "${APP_NAME}" | \
                yq w - version "1.0.0-rc${IMAGE_VERSION}" > "${CHART_ROOT}/${APP_NAME}/Chart.yaml"
          else
            echo "Chart name and image name match: ${APP_NAME}"
          fi

          CHART_PATH="${CHART_ROOT}/${APP_NAME}"

          RELEASE_NAME="${APP_NAME}"
          echo "RELEASE_NAME: $RELEASE_NAME"

          echo $(helm version)

          echo "CHECKING CHART (lint)"
          helm lint ${CHART_PATH}

          PREFIX=""
          if [[ -f "${CHART_PATH}/requirements.yaml" ]] || grep -Eq "^dependencies:" "${CHART_PATH}/Chart.yaml"; then
              DEPENDENCY_FILE="${CHART_PATH}/Chart.yaml"
              if [[ -f "${CHART_PATH}/requirements.yaml" ]]; then
                  DEPENDENCY_FILE="${CHART_PATH}/requirements.yaml"
              fi

              PREFIX="$(yq r -j "${DEPENDENCY_FILE}" | jq -r '.dependencies | .[] | .alias // .name' | head -1)."
          fi

          # Update helm chart with repository and tag values
          cat ${CHART_PATH}/values.yaml | \
              yq w - "${PREFIX}nameOverride" "${APP_NAME}" | \
              yq w - "${PREFIX}fullnameOverride" "${APP_NAME}" | \
              yq w - "${PREFIX}vcsInfo.repoUrl" "${GIT_URL}" | \
              yq w - "${PREFIX}vcsInfo.branch" "${GIT_REVISION}" | \
              yq w - "${PREFIX}image.repository" "${IMAGE_URL}" | \
              yq w - --style single "${PREFIX}image.tag" "${IMAGE_VERSION}" | \
              yq w - "${PREFIX}ingress.enabled" "${INGRESS_ENABLED}" | \
              yq w - "${PREFIX}route.enabled" "${ROUTE_ENABLED}" > ./values.yaml.tmp
          cp ./values.yaml.tmp ${CHART_PATH}/values.yaml
          cat ${CHART_PATH}/values.yaml

          helm dep update "${CHART_PATH}"

          # Using 'upgrade --install" for rolling updates. Note that subsequent updates will occur in the same namespace the release is currently deployed in, ignoring the explicit--namespace argument".
          helm template ${RELEASE_NAME} ${CHART_PATH} \
              --namespace ${APP_NAMESPACE} \
              --set ${PREFIX}ingress.tlsSecretName="${TLS_SECRET_NAME}" \
              --set ${PREFIX}ingress.subdomain="${INGRESS_SUBDOMAIN}" > ./release.yaml

          echo -e "Generated release yaml for: ${APP_NAMESPACE}/${APP_NAME}"
          cat ./release.yaml

          echo -e "Deploying into: ${APP_NAMESPACE}/${APP_NAME}"
          kubectl apply -n ${APP_NAMESPACE} -f ./release.yaml --validate=false > results.out
          cat results.out
          echo "Waiting for rollout of ${APP_NAMESPACE}/${APP_NAME}"


          cat results.out | \
            grep -E "deployment|statefulset|integrationserver|queuemanager" | \
            sed "s/deployment.apps/deployment/g" | \
            sed "s/statefulset.apps/statefulset/g" | \
            sed "s/configured//g" | \
            sed "s/created//g" | \
            sed "s/unchanged//g" | while read target; do
            echo "Waiting for rollout of ${target} in ${APP_NAMESPACE}"
            if [[ ${target} == *"integrationserver"* ]]; then
              kubectl wait --timeout=-1s --for=condition=Ready ${target}
            elif [[ ${target} == *"queuemanager"* ]]; then
              until [[ "$(kubectl get ${target} -o 'jsonpath={.status.phase}')" = "Running" ]];
              do
              sleep 5
              echo "Waiting for Queuemanager to be ready."
              done
            else
              kubectl rollout status -n ${APP_NAMESPACE} ${target}
              SERVICE_PORT=$(kubectl get svc "${APP_NAME}" -n "${APP_NAMESPACE}" -o jsonpath="{.spec.ports[?(@.name == 'http')].port}")
              echo -n "${SERVICE_PORT}" | tee $(results.service-port.path)
            fi
            echo -n "${target}" | cut -f1 -d / | tee $(results.resource-type.path)
          done
    - name: health-check
      image: $(params.tools-image)
      script: |
          #!/usr/bin/env bash
          set -x

          APP_NAME="$(params.app-name)"

          # RELEASE_NAME="${APP_NAME}"
          RELEASE_NAME="qm-dev"
          echo "RELEASE_NAME: $RELEASE_NAME"

          podname=$(kubectl get pods --selector=app.kubernetes.io/instance=$RELEASE_NAME -o custom-columns=POD:.metadata.name --no-headers | head -n 1)
          echo "podname: $podname"

          queue="QM1"
          echo "queue name: $queue"

          echo "Sleep before test to make sure QMGR is up"
          sleep 20

          echo "Print the queue details: ..."
          echo ""
          kubectl exec $podname -- /bin/bash -c "echo \"define qlocal($queue) replace\" | runmqsc "

          echo "Print the queue details: ..."
          echo ""
          kubectl exec $podname -- /bin/bash -c "echo \"DISPLAY QL($queue) ALL\" | runmqsc" > checkQ.txt 2>&1
          cat checkQ.txt

          if grep -q "QUEUE($queue)" checkQ.txt; then
            echo "Queue has been successfully created."
          else
            exit 1
          fi

          # put message on queue
          kubectl exec $podname -- /bin/bash -c "echo \"hello-world\" | /opt/mqm/samp/bin/amqsput $queue" > putMessage.txt 2>&1
          cat putMessage.txt
          echo "----------"
          fail="reason code"
          if grep -q "$fail" putMessage.txt; then
            exit 1
          else
            echo "Message has been successfully put the queue."
          fi

          # get message on queue
          kubectl exec $podname  -c qmgr -- /opt/mqm/samp/bin/amqsget $queue > getMessage.txt 2>&1
          cat getMessage.txt
          if grep -q "hello-world" getMessage.txt; then
              echo "Message has been found on the queue."
          else
              echo "Error: Message has not been retrieved from the queue."
              exit 1
          fi
    - name: cleanup
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: TLS_SECRET_NAME
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: TLS_SECRET_NAME
              optional: true
        - name: INGRESS_SUBDOMAIN
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: INGRESS_SUBDOMAIN
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex

          APP_NAMESPACE="$(params.app-namespace)"

          kubectl delete -n ${APP_NAMESPACE} -f ./release.yaml

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-nodejs-test-v2-6-13
  annotations:
    description: Executes build, test, and sonarscan logic for a NodeJS application
    app.openshift.io/description: Executes build, test, and sonarscan logic for a NodeJS application
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: app-name
      default: ''
    - name: source-dir
      default: /source
    - name: js-image
      default: quay.io/ibmgaragecloud/node:lts-stretch
    - name: sonarqube-cli
      default: quay.io/ibmgaragecloud/sonarsource-sonar-scanner-cli
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: build
      image: $(params.js-image)
      workingDir: $(params.source-dir)
      env:
      - name: npm_config_registry
        valueFrom:
          secretKeyRef:
            name: npm-config
            key: npm_config_registry
            optional: true
      script: |
        npm install
        if [ -d client ]; then
          cd client
          npm install
          cd -
        fi
        npm run build --if-present
    - name: test
      image: $(params.js-image)
      workingDir: $(params.source-dir)
      script: |
        CI=true npm test
    - name: publish-pact
      image: $(params.js-image)
      workingDir: $(params.source-dir)
      env:
        - name: PACTBROKER_URL
          valueFrom:
            secretKeyRef:
              name: pactbroker-access
              key: PACTBROKER_URL
              optional: true
      script: |
        if [ -n "${PACTBROKER_URL}" ]; then
            npm run pact:publish --if-present
        else
            echo "Skipping Pact publish"
        fi
    - name: verify-pact
      image: $(params.js-image)
      workingDir: $(params.source-dir)
      env:
        - name: PACTBROKER_URL
          valueFrom:
            secretKeyRef:
              name: pactbroker-access
              key: PACTBROKER_URL
              optional: true
      script: |
        if [ -n "${PACTBROKER_URL}" ]; then
            npm run pact:verify --if-present
        else
            echo "Skipping Pact publish"
        fi
    - name: sonar-scan
      image: $(params.sonarqube-cli)
      workingDir: $(params.source-dir)
      env:
        - name: SONAR_USER_HOME
          value: $(params.source-dir)
        - name: SONARQUBE_URL
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_URL
              optional: true
        - name: SONARQUBE_USER
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_USER
              optional: true
        - name: SONARQUBE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_PASSWORD
              optional: true
      script: |
        APP_NAME=$(params.app-name)

        if ! command -v sonar-scanner &> /dev/null
        then
            echo "Skipping SonarQube step, no task defined"
            exit 0
        fi

        if [ -n "${SONARQUBE_URL}" ]; then

           sonar-scanner \
            -Dsonar.login=${SONARQUBE_USER} \
            -Dsonar.password=${SONARQUBE_PASSWORD} \
            -Dsonar.host.url=${SONARQUBE_URL} \
            -Dsonar.projectKey=${APP_NAME}

        else
            echo "Skipping Sonar Qube step"
        fi


---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-img-release-v2-6-13
  annotations:
    description: Tags the git repository and releases the intermediate container image with the version tag
    app.openshift.io/description: Tags the git repository and releases the intermediate container image with the version tag
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: image-from
      default: ""
    - name: image-to
      default: ""
    - name: SKOPEO_IMAGE
      default: quay.io/containers/skopeo:v1.1.0
    - name: IMAGE_FROM_TLS_VERIFY
      default: "true"
    - name: IMAGE_TO_TLS_VERIFY
      default: "true"
  results:
    - name: image-url
      description: The url of the image to be pushed
  volumes:
    - name: varlibcontainers
      emptyDir: {}
  steps:
    - name: image-tag
      image: $(params.SKOPEO_IMAGE)
      env:
        - name: REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_USER
              optional: true
        - name: REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_PASSWORD
              optional: true
      volumeMounts:
        - mountPath: /var/lib/containers
          name: varlibcontainers
      securityContext:
        privileged: true
      script: |
        IMAGE_FROM="$(params.image-from)"
        REGISTRY_SERVER_FROM=$(echo "${IMAGE_FROM}" | awk -F / '{print $1}')
        IMAGE_TO="$(params.image-to)"
        REGISTRY_SERVER_TO=$(echo "${IMAGE_TO}" | awk -F / '{print $1}')
        IMAGE_FROM_TLS_VERIFY=$(params.IMAGE_FROM_TLS_VERIFY)
        IMAGE_TO_TLS_VERIFY=$(params.IMAGE_TO_TLS_VERIFY)

        echo "Tagging ${IMAGE_FROM} as ${IMAGE_TO}"
        set +x
        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ ! "${REGISTRY_SERVER_FROM}" =~ ":" ]]; then
          IMAGE_FROM_CREDS="--src-creds ${REGISTRY_USER}:${REGISTRY_PASSWORD}"
        fi
        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ ! "${REGISTRY_SERVER_TO}" =~ ":" ]]; then
          IMAGE_TO_CREDS="--dest-creds ${REGISTRY_USER}:${REGISTRY_PASSWORD}"
        fi
        set -x
        if [[ "${REGISTRY_SERVER_FROM}" =~ ":" ]]; then
          IMAGE_FROM_TLS_VERIFY="false"
        fi
        if [[ "${REGISTRY_SERVER_TO}" =~ ":" ]]; then
          IMAGE_TO_TLS_VERIFY="false"
        fi

        echo "skopeo copy --src-creds=xxxx --src-tls-verify=${IMAGE_FROM_TLS_VERIFY} --dest-creds=xxxx --dest-tls-verify=${IMAGE_TO_TLS_VERIFY} docker://${IMAGE_FROM} docker://${IMAGE_TO}"
        set +x
        skopeo copy ${IMAGE_FROM_CREDS} --src-tls-verify=${IMAGE_FROM_TLS_VERIFY} ${IMAGE_TO_CREDS} --dest-tls-verify=${IMAGE_TO_TLS_VERIFY} docker://${IMAGE_FROM} docker://${IMAGE_TO}
        set -x
        echo -n "${IMAGE_TO}" | tee $(results.image-url.path)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-golang-test-v2-6-13
  annotations:
    description: Executes build, test, and sonarscan logic for a Golang application
    app.openshift.io/description: Executes build, test, and sonarscan logic for a Golang application
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: app-name
      default: "my-golang-app"
    - name: golang-image
      default: quay.io/ibmgaragecloud/golang:stretch
    - name: sonarqube-cli
      default: quay.io/ibmgaragecloud/sonarsource-sonar-scanner-cli
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: build
      image: $(params.golang-image)
      workingDir: $(params.source-dir)
      script: |
          go build ./...
    - name: test
      image: $(params.golang-image)
      workingDir: $(params.source-dir)
      script: |
          go test ./...
    - name: sonar-scan
      image: $(params.sonarqube-cli)
      workingDir: $(params.source-dir)
      env:
        - name: SONAR_USER_HOME
          value: $(params.source-dir)
        - name: SONARQUBE_URL
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_URL
              optional: true
        - name: SONARQUBE_USER
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_USER
              optional: true
        - name: SONARQUBE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_PASSWORD
              optional: true
      script: |
          APP_NAME=$(params.app-name)

          if ! command -v sonar-scanner &> /dev/null
          then
              echo "Skipping SonarQube step, no task defined"
              exit 0
          fi

          if [ -n "${SONARQUBE_URL}" ]; then

            sonar-scanner \
            -Dsonar.login=${SONARQUBE_USER} \
            -Dsonar.password=${SONARQUBE_PASSWORD} \
            -Dsonar.host.url=${SONARQUBE_URL} \
            -Dsonar.projectKey=${APP_NAME}

          else
              echo "Skipping Sonar Qube step for now but include"
          fi

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-img-scan-ibm-v2-6-13
  annotations:
    description: Checks the results for the Vulnerability Advisor scan if deploying images to IBM Container Registry
    app.openshift.io/description: Checks the results for the Vulnerability Advisor scan if deploying images to IBM Container Registry
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: image-url
      description: "The location of image to scan on IBM Container Registry <server>/<namespace>/<repository>:<tag>"
    - name: scan-image
      description: Flag indicating that a scan should be performed
      default: "false"
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
    - name: source-dir
      default: /source
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: scan-image
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: HOME
          value: /home/devops
        - name: IBM_CLOUD_APIKEY
          valueFrom:
            secretKeyRef:
              key: APIKEY
              name: ibmcloud-apikey
              optional: true
        - name: IBM_CLOUD_REGION
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: REGION
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex

          IMAGE_URL=$(params.image-url)
          REGISTRY_SERVER=$(echo $(params.image-url) | awk -F / '{print $1}')
          PERFORM_SCAN="$(params.scan-image)"

          if [[ "${PERFORM_SCAN}" == "false" ]] || [[ -z "${PERFORM_SCAN}" ]]; then
            echo "User selected to skip scanning. Skipping Vulnerability Advisor validation."
            exit 0
          fi
          if [[ ! "${REGISTRY_SERVER}" =~ icr.io ]]; then
            echo "The image is not stored in the IBM Cloud Image Registry. Skipping Vulnerability Advisor validation"
            exit 0
          fi


          echo -e "VA Security Scan image in registry"

          echo "Registry URL: ${REGISTRY_SERVER}"

          set +x
          ibmcloud login --apikey ${IBM_CLOUD_APIKEY} -r ${IBM_CLOUD_REGION}
          ibmcloud target -r ${IBM_CLOUD_REGION}
          set -x
          ibmcloud cr namespace-list

          echo "Getting the VA status of ${IMAGE_URL}"

          set +e
          ibmcloud cr va ${IMAGE_URL} --output json | grep -i "Try again later"
          retry=$?
          while [ $retry -eq 0 ]; do
            sleep 30
            echo "Trying again to see if scan is done"
            ibmcloud cr va ${IMAGE_URL} --output json | grep -i "Try again later"
            retry=$?
          done
          set -e
          ibmcloud cr va ${IMAGE_URL} --output json
          echo "Saving results to va-result.json"
          ibmcloud cr va ${IMAGE_URL} --output json > va-result.json
          VA_STATUS=$(cat va-result.json | jq -r '.[].status')

          echo "VA scan status: ${VA_STATUS}"

          if [[ "${VA_STATUS}" == "OK" ]]; then
            echo "VA - No Issues in the image"
            exit 0
          elif [[ $(cat va-result.json | jq -r '.[].vulnerabilities | length') -gt 0 ]]; then
            echo "VA Failure: $(cat va-result.json | jq -r '.[].vulnerabilities | length') vulnerabilities found in the image"
            cat va-result.json | jq -r '.[].vulnerabilities'
            exit 1
          elif [[ $(cat va-result.json | jq -r '.[].configuration_issues | length') -gt 0 ]]; then
            echo "VA Warning - $(cat va-result.json | jq -r '.[].configuration_issues | length') configuration issues found in the image"
            cat va-result.json | jq -r '.[].configuration_issues'
            exit 0
          else
            echo "VA Warning: non-OK status from Vulnerability Advisor ${VA_STATUS}"
            cat va-result.json | jq -r '.[]'
          fi

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-build-tag-push-ace-bar-v2-6-13
  annotations:
    description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
  - name: git-url
  - name: git-revision
    default: master
  - name: source-dir
    default: /source
  - name: image-server
    default: ""
  - name: image-namespace
    default: ""
  - name: image-repository
    default: ""
  - name: image-tag
    default: ""
  - name: BUILDER_IMAGE
    default: quay.io/buildah/stable:v1.15.0
  - name: DOCKERFILE
    default: ./Dockerfile
  - name: CONTEXT
    default: .
  - name: TLSVERIFY
    default: "false"
  - name: FORMAT
    default: docker
  - name: STORAGE_DRIVER
    description: Set buildah storage driver
    default: overlay
  - name: app-name
    default: ""
  - name: ace-project
    default: ""
  volumes:
  - name: varlibcontainers
    emptyDir: {}
  - name: source
    emptyDir: {}
  stepTemplate:
    volumeMounts:
    - name: source
      mountPath: $(params.source-dir)
  steps:
  - name: git-clone
    image: quay.io/ibmgaragecloud/alpine-git
    env:
    - name: GIT_PASSWORD
      valueFrom:
        secretKeyRef:
          key: password
          name: git-credentials
          optional: true
    - name: GIT_USERNAME
      valueFrom:
        secretKeyRef:
          key: username
          name: git-credentials
          optional: true
    script: |
      set +x
      if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
          git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
      else
          set -x
          git clone $(params.git-url) $(params.source-dir)
      fi
      set -x
      cd $(params.source-dir)
      git checkout $(params.git-revision)
  - name: compile
    image: docker.io/rsundara/ace-build
    envFrom:
    - secretRef:
        name: artifactory-access
    command:
    - /bin/sh
    args:
    - -c
    - |
      set -eu;
      echo "Compile BAR";

      # Used for debugging with mqsicreatebar
      /usr/bin/Xvfb :100 &
      export DISPLAY=:100

      cd $(params.source-dir)/workspace
      echo "Generating BAR"
      mqsicreatebar -data . -b $(params.source-dir)/$(params.app-name)-$(params.image-tag).bar -a $(params.ace-project)

      echo "Upload BAR to Artifactory"
      curl -u ${ARTIFACTORY_USER}:${ARTIFACTORY_ENCRYPT} -T $(params.source-dir)/$(params.app-name)-$(params.image-tag).bar "$(ARTIFACTORY_URL)/artifactory/generic-local/$(params.app-name)-$(params.image-tag).bar"
  - name: build
    image: $(params.BUILDER_IMAGE)
    workingDir: $(params.source-dir)
    env:
    - name: REGISTRY_USER
      valueFrom:
        secretKeyRef:
          key: REGISTRY_USER
          name: registry-access
          optional: true
    - name: REGISTRY_PASSWORD
      valueFrom:
        secretKeyRef:
          key: REGISTRY_PASSWORD
          name: registry-access
          optional: true
    envFrom:
    - secretRef:
        name: ibm-entitled-registry-credentials
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
    securityContext:
      privileged: true
    script: |
      APP_IMAGE="$(params.image-server)/$(params.image-namespace)/$(params.image-repository):$(params.image-tag)"
      buildah login -u ${IBM_ENTITLED_REGISTRY_USER} -p ${IBM_ENTITLED_REGISTRY_PASSWORD} cp.icr.io
      buildah --layers --storage-driver=$(params.STORAGE_DRIVER) bud --format=$(params.FORMAT) --tls-verify=$(params.TLSVERIFY) -f $(params.DOCKERFILE) -t ${APP_IMAGE} $(params.CONTEXT)
      set +x
      if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ "$(params.image-server)" != "image-registry.openshift-image-registry.svc:5000"  ]]; then
        buildah login -u "${REGISTRY_USER}" -p "${REGISTRY_PASSWORD}" "$(params.image-server)"
        echo "buildah login -u "${REGISTRY_USER}" -p "xxxxx" "$(params.image-server)""
      fi
      set -x
      buildah --storage-driver=$(params.STORAGE_DRIVER) push --tls-verify=$(params.TLSVERIFY) --digestfile ./image-digest ${APP_IMAGE} docker://${APP_IMAGE}

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-java-gradle-test-v2-6-13
  annotations:
    description: Executes build, test, and sonarscan logic for a Java gradle application
    app.openshift.io/description: Executes build, test, and sonarscan logic for a Java gradle application
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: app-name
      default: "my-java-gradle-app"
    - name: gradle-image
      default: quay.io/ibmgaragecloud/gradle:jdk11
    - name: sonarqube-java-bin-path
      default: build
    - name: sonarqube-cli
      default: quay.io/ibmgaragecloud/sonarsource-sonar-scanner-cli
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    env:
      - name: GRADLE_USER_HOME
        value: $(params.source-dir)
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: build
      image: $(params.gradle-image)
      workingDir: $(params.source-dir)
      script: |
          ./gradlew assemble --no-daemon
    - name: test
      image: $(params.gradle-image)
      workingDir: $(params.source-dir)
      script: |
          ./gradlew testClasses --no-daemon
    - name: sonar-scan
      image: $(params.sonarqube-cli)
      workingDir: $(params.source-dir)
      env:
        - name: SONAR_USER_HOME
          value: $(params.source-dir)
        - name: SONARQUBE_URL
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_URL
              optional: true
        - name: SONARQUBE_USER
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_USER
              optional: true
        - name: SONARQUBE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_PASSWORD
              optional: true
      script: |
          APP_NAME=$(params.app-name)
          SONARQUBE_JAVA_BINARIES_PATH="$(params.sonarqube-java-bin-path)"

          if ! command -v sonar-scanner &> /dev/null
          then
              echo "Skipping SonarQube step, no task defined"
              exit 0
          fi

          if [ -n "${SONARQUBE_URL}" ]; then

            sonar-scanner \
            -Dsonar.login=${SONARQUBE_USER} \
            -Dsonar.password=${SONARQUBE_PASSWORD} \
            -Dsonar.host.url=${SONARQUBE_URL} \
            -Dsonar.projectKey=${APP_NAME} \
            -Dsonar.java.binaries=${SONARQUBE_JAVA_BINARIES_PATH}

          else
              echo "Skipping Sonar Qube step for now but include"
          fi

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-operator-test-v2-6-13
  annotations:
    description: Executes build, test, and sonarscan logic for a Java gradle application
    app.openshift.io/description: Executes build, test, and sonarscan logic for a Java gradle application
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: app-name
      default: "my-java-gradle-app"
    - name: build-image
      default: quay.io/ibmgaragecloud/operator-sdk:v0.10.4
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: test
      image: $(params.build-image)
      workingDir: $(params.source-dir)
      script: |
        make test

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-operator-catalog-build-v2-6-13
  annotations:
    description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/description: Executes logic to build, tag and push a container image using the intermediate sha tag to the image-url
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: subdir
      default: ""
    - name: image-url
      default: ""
    - name: OPM_IMAGE
      default: quay.io/ibmgaragecloud/operator-sdk:v0.10.4
    - name: BUILDER_IMAGE
      default: quay.io/buildah/stable:v1.15.1
    - name: DOCKERFILE
      default: ./index.Dockerfile
    - name: CONTEXT
      default: .
    - name: TLSVERIFY
      default: "true"
    - name: FORMAT
      default: "docker"
    - name: BUNDLE_CATALOG
      default: "bundles.txt"
    - name: STORAGE_DRIVER
      description: Set buildah storage driver
      default: overlay
  volumes:
    - name: varlibcontainers
      emptyDir: {}
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: generate-catalog
      image: $(params.OPM_IMAGE)
      workingDir: $(params.source-dir)
      env:
        - name: REGISTRY_URL
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_URL
              optional: true
        - name: REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_USER
              optional: true
        - name: REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_PASSWORD
              optional: true
        - name: GIT_PARENT_DIR
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: parentdir
              optional: true
      volumeMounts:
        - mountPath: /var/lib/containers
          name: varlibcontainers
      securityContext:
        privileged: true
      script: |

        if [[ -n "${GIT_PARENT_DIR}" ]]; then
          cd "${GIT_PARENT_DIR}"
        fi

        if [[ -n "$(params.subdir)" ]]; then
          cd "$(params.subdir)"
        fi

        if [[ "$(params.TLSVERIFY)" == "false" ]] || [[ "${REGISTRY_URL}" == "image-registry.openshift-image-registry.svc:5000" ]]; then
          SKIPTLS="--skip-tls=true"
        fi

        touch $(params.BUNDLE_CATALOG)

        BUNDLES=$(cat $(params.BUNDLE_CATALOG) | paste -sd "," -)

        set +x

        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ -n "{REGISTRY_URL}" ]] && [[ "${REGISTRY_URL}" != "image-registry.openshift-image-registry.svc:5000"  ]]; then
          mkdir -p "${HOME}/.docker"
          echo "podman login -u "${REGISTRY_USER}" -p "xxxxx" --authfile="${HOME}/.docker/config.json" "${REGISTRY_URL}""
          podman login -u "${REGISTRY_USER}" -p "${REGISTRY_PASSWORD}" --authfile="${HOME}/.docker/config.json" "${REGISTRY_URL}"
        fi

        set -x

        opm index add ${SKIPTLS} --bundles "${BUNDLES}" --generate -d $(params.DOCKERFILE)
    - name: build
      image: $(params.BUILDER_IMAGE)
      workingDir: $(params.source-dir)
      env:
        - name: REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_USER
              optional: true
        - name: REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_PASSWORD
              optional: true
        - name: GIT_PARENT_DIR
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: parentdir
              optional: true
      volumeMounts:
        - mountPath: /var/lib/containers
          name: varlibcontainers
      securityContext:
        privileged: true
      script: |

        if [[ -n "${GIT_PARENT_DIR}" ]]; then
          cd "${GIT_PARENT_DIR}"
        fi
        if [[ -n "$(params.subdir)" ]]; then
          cd "$(params.subdir)"
        fi

        IMAGE_TO="$(params.image-url)"
        REGISTRY_SERVER_TO=$(echo "${IMAGE_TO}" | awk -F / '{print $1}')

        buildah --layers --storage-driver=$(params.STORAGE_DRIVER) bud --format=$(params.FORMAT) --tls-verify=$(params.TLSVERIFY) -f $(params.DOCKERFILE) -t ${IMAGE_TO} $(params.CONTEXT)
        set +x
        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ ! "${REGISTRY_SERVER_TO}" =~ ":" ]]; then
          buildah login -u "${REGISTRY_USER}" -p "${REGISTRY_PASSWORD}" ${REGISTRY_SERVER_TO}
          echo "buildah login -u "${REGISTRY_USER}" -p "xxxxx" ${REGISTRY_SERVER_TO}"
        fi
        set -x
        buildah --storage-driver=$(params.STORAGE_DRIVER) push --tls-verify=$(params.TLSVERIFY) --digestfile ./image-digest ${APP_IMAGE} docker://${IMAGE_TO}

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-sonar-test-v2-6-13
  annotations:
    description: Executes build, test, and sonarscan logic for a Python application
    app.openshift.io/description: Executes build, test, and sonarscan logic for a NodeJS application
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: app-name
      default: ''
    - name: source-dir
      default: /source
    - name: sonarqube-cli
      default: quay.io/ibmgaragecloud/sonarsource-sonar-scanner-cli
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: sonar-scan
      image: $(params.sonarqube-cli)
      workingDir: $(params.source-dir)
      env:
        - name: SONAR_USER_HOME
          value: $(params.source-dir)
        - name: SONARQUBE_URL
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_URL
              optional: true
        - name: SONARQUBE_USER
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_USER
              optional: true
        - name: SONARQUBE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_PASSWORD
              optional: true
      script: |
        APP_NAME=$(params.app-name)

        if ! command -v sonar-scanner &> /dev/null
        then
            echo "Skipping SonarQube step, no task defined"
            exit 0
        fi

        if [ -n "${SONARQUBE_URL}" ]; then

           sonar-scanner \
            -Dsonar.login=${SONARQUBE_USER} \
            -Dsonar.password=${SONARQUBE_PASSWORD} \
            -Dsonar.host.url=${SONARQUBE_URL} \
            -Dsonar.projectKey=${APP_NAME}

        else
            echo "Skipping Sonar Qube step"
        fi


---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-tag-release-v2-6-13
  annotations:
    description: Tags the git repository with the next version release value
    app.openshift.io/description: Tags the git repository with the next version release value
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: skip-push
      default: ""
    - name: js-image
      default: quay.io/ibmgaragecloud/node:lts-stretch
  results:
    - name: tag
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
        # Need to create  branch to make release-it work
        git switch -c local
    - name: git-tag
      image: $(params.js-image)
      workingDir: $(params.source-dir)
      script: |
        #!/usr/bin/env bash
        set -ex

        echo "Current branch: $(git rev-parse --abbrev-ref HEAD)"
        git fetch --tags
        git config --global user.email "cloud-native-toolkit@example.com"
        git config --global user.name "Cloud Native Toolkit Pipeline"
        if [[ $(git describe --tag `git rev-parse HEAD`) =~ (^[0-9]+.[0-9]+.[0-9]+$) ]]; then
            echo "Latest commit is already tagged"
            NEW_TAG="$(git describe --abbrev=0 --tags)"
            echo -n "${NEW_TAG}" | tee $(results.tag.path)
            exit 0
        fi
        mkdir -p ~/.npm
        npm config set prefix ~/.npm
        export PATH=$PATH:~/.npm/bin
        npm i -g release-it

        release-it patch \
          --ci \
          --no-npm \
          --no-git.push \
          --no-git.requireCleanWorkingDir \
          --no-git.requireUpstream \
          -VV

        if [[ -z "$(params.skip-push)" ]]; then
          set +x
          git push --tags -v
          set -x
        fi

        NEW_TAG="$(git describe --abbrev=0 --tags)"
        if [[ -z "${NEW_TAG}" ]]; then
            echo "Error: NEW_TAG not defined"
            exit 1
        fi
        echo -n "${NEW_TAG}" | tee $(results.tag.path)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-gitops-with-pr-v2-6-13
  annotations:
    description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: app-name
      default: ""
    - name: version
      default: ""
    - name: source-dir
      default: /source
    - name: subdir
      default: ""
    - name: parentdir
      default: ""
    - name: yaml
      default: "requirements.yaml"
    - name: helm-url
      default: ""
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: gitops
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: HOME
          value: /home/devops
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME_CD
          valueFrom:
            secretKeyRef:
              name: gitops-cd-secret
              key: username
              optional: true
        - name: GIT_PASSWORD_CD
          valueFrom:
            secretKeyRef:
              name: gitops-cd-secret
              key: password
              optional: true
        - name: GIT_PARENT_DIR
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: parentdir-services
              optional: true
        - name: GIT_PROTOCOL
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: protocol
              optional: true
        - name: GIT_HOST
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: host
              optional: true
        - name: GIT_ORG
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: org
              optional: true
        - name: GIT_REPO
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: repo
              optional: true
        - name: GIT_BRANCH
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: branch
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex

          APP_NAME="$(params.app-name)"
          SUBDIR="$(params.subdir)"
          if [[ -z "${SUBDIR}" ]]; then
            SUBDIR="${APP_NAME}"
          fi
          if [[ -n "$(params.parentdir)" ]]; then
            PARENT_DIR="$(params.parentdir)"
          elif [[ -n "${GIT_PARENT_DIR}" ]] && [[ "${GIT_PARENT_DIR}" = "bash -c"* ]]; then
            PARENT_DIR=$(eval $GIT_PARENT_DIR | tail -n 1)
          elif [[ -n "${GIT_PARENT_DIR}" ]]; then
            PARENT_DIR="${GIT_PARENT_DIR}"
          else
            PARENT_DIR="."
          fi
          SUBDIR="${PARENT_DIR}/${SUBDIR}"

          PROTOCOL="${GIT_PROTOCOL}"
          if [[ -z "${PROTOCOL}" ]]; then
            PROTOCOL="https"
          fi

          YAML_FILE="$(params.yaml)"
          VERSION="$(params.version)"
          HELM_URL="$(params.helm-url)"

          if [[ -z "${GIT_HOST}" ]] || [[ -z "${GIT_ORG}" ]] || [[ -z "${GIT_REPO}" ]]; then
              echo "GitOps repo has not been configured with confimap gitops-repo. Skipping trigger step"
              exit 0
          fi

          set +x
          if [[ -n "${GIT_USERNAME_CD}" ]]; then
            GIT_AUTH_USER="${GIT_USERNAME_CD}"
            GIT_AUTH_PWD="${GIT_PASSWORD_CD}"
          elif [[ -n "${GIT_USERNAME}" ]]; then
            GIT_AUTH_USER="${GIT_USERNAME}"
            GIT_AUTH_PWD="${GIT_PASSWORD}"
          else
            echo "Credentials for GitOps repo not set in secret gitops-cd-secret or git-credentials"
            exit 1
          fi
          set -x

          BRANCH_CMD=""
          if [[ -n "${GIT_BRANCH}" ]]; then
            BRANCH_CMD="-b ${GIT_BRANCH}"
          fi

          git config --global user.email "gitops@cloudnativetoolkit.dev"
          git config --global user.name "Cloud Native Toolkit Pipeline"
          echo "git clone ${BRANCH_CMD} ${PROTOCOL}://${GIT_AUTH_USER}:xxxx@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
          set +x
          GIT_URL="${PROTOCOL}://${GIT_AUTH_USER}:${GIT_AUTH_PWD}@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
          git clone ${BRANCH_CMD} ${GIT_URL} gitops_cd
          set -x
          cd gitops_cd

          if [[ -f "${SUBDIR}/${YAML_FILE}" ]]; then
            echo "Requirements before update"
            cat "${SUBDIR}/${YAML_FILE}"

            yq r "${SUBDIR}/${YAML_FILE}" -j | \
              jq --arg APP_NAME "${APP_NAME}" --arg VERSION "${VERSION}" --arg REPO "${HELM_URL}" '.dependencies |= map((select(.name == $APP_NAME) | .version = $VERSION | .repository = $REPO) // .)' | \
              yq r --prettyPrint - > "${SUBDIR}/${YAML_FILE}.new"

            rm "${SUBDIR}/${YAML_FILE}"
            mv "${SUBDIR}/${YAML_FILE}.new" "${SUBDIR}/${YAML_FILE}"

            echo "Requirements after update"
            cat "${SUBDIR}/${YAML_FILE}"

          elif [[ -n "${HELM_URL}" ]]; then
            echo "Creating first time chart using ${SUBDIR}"
            # create directory
            mkdir -p "${SUBDIR}"

            # WARNING: Do not indent the cat commands below

          cat <<EOF >"${SUBDIR}/Chart.yaml"
          apiVersion: v2
          version: 0.1.0
          name: ${APP_NAME}
          description: Chart to configure ArgoCD with the ${APP_NAME} project and its applications
          EOF

          cat <<EOF >"${SUBDIR}/${YAML_FILE}"
          dependencies:
            - name: ${APP_NAME}
              version: ${VERSION}
              repository: >-
                ${HELM_URL}
          EOF

          cat <<EOF >"${SUBDIR}/values.yaml"
          global: {}
          ${APP_NAME}:
            replicaCount: 1
          EOF


          else
            echo "GitOps repo configured but unable to update application config"
            exit 1
          fi

          if [[ $(git status -s | wc -l) -eq 0 ]]; then
            echo "No changes"
            exit 0
          fi

          git checkout -b cntk-ci-pipeline-${APP_NAME}-${VERSION}

          # push changes to git
          git add "${SUBDIR}/"
          git commit -m "Cloudnative toolkit pipeline updates ${APP_NAME} to ${VERSION}"
          git remote rm origin

          git remote add origin ${GIT_URL} > /dev/null 2>&1
          git push origin cntk-ci-pipeline-${APP_NAME}-${VERSION}

          GIT_PUSH_URL="${PROTOCOL}://api.github.com/repos/${GIT_ORG}/${GIT_REPO}/pulls"
          curl -u ${GIT_AUTH_USER}:${GIT_AUTH_PWD} -d '{"title":"PR to promote to next environment","base":"'${GIT_BRANCH}'", "head":"'${GIT_ORG}':cntk-ci-pipeline-'${APP_NAME}'-'${VERSION}'"}' ${GIT_PUSH_URL}

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-deploy-v2-6-13
  annotations:
    description: Deploys the application to the CI environment for verification using the provided helm chart
    app.openshift.io/description: Deploys the application to the CI environment for verification using the provided helm chart
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: image-server
      default: ""
    - name: image-namespace
      default: ""
    - name: image-repository
      default: ""
    - name: image-tag
      default: ""
    - name: app-namespace
      default: ""
    - name: app-name
      default: ""
    - name: deploy-ingress-type
      default: "route"
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  results:
    - name: service-port
    - name: resource-type
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: deploy
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: TLS_SECRET_NAME
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: TLS_SECRET_NAME
              optional: true
        - name: INGRESS_SUBDOMAIN
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: INGRESS_SUBDOMAIN
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex
          GIT_URL="$(params.git-url)"
          GIT_REVISION="$(params.git-revision)"
          APP_NAMESPACE="$(params.app-namespace)"
          APP_NAME="$(params.app-name)"
          if [[ -z "${APP_NAME}" ]]; then
            APP_NAME="$(params.image-repository)"
          fi
          IMAGE_SERVER="$(params.image-server)"
          IMAGE_NAMESPACE="$(params.image-namespace)"
          IMAGE_REPOSITORY="$(params.image-repository)"
          IMAGE_VERSION="$(params.image-tag)"
          IMAGE_URL="${IMAGE_SERVER}/${IMAGE_NAMESPACE}/${IMAGE_REPOSITORY}"
          INGRESS_TYPE="$(params.deploy-ingress-type)"
          if [[ "${INGRESS_TYPE}" == "route" ]]; then
            ROUTE_ENABLED="true"
            INGRESS_ENABLED="false"
          else
            ROUTE_ENABLED="false"
            INGRESS_ENABLED="true"
          fi

          export CHART_ROOT=$(find . -name chart)
          echo "CHART_ROOT: $CHART_ROOT"

          FILE_NUM=$(find . -name 'Chart*.yaml' |wc -l)
          if [[ "${FILE_NUM}" -gt 1 ]]; then
            echo "Error: Found >1 Chart*.yaml"
            exit 1
          fi

          export CHART=$(find . -name 'Chart*.yaml')
          echo "CHART: $CHART"

          export CHART_NAME=$(cat $CHART | yq r - name)
          echo "CHART_NAME: $CHART_NAME"

          # Update Chart name and version
          if [[ "${CHART_NAME}" != "${APP_NAME}" ]]; then
            echo "Renaming chart from ${CHART_NAME} to ${APP_NAME}"
            cp -R "${CHART_ROOT}/${CHART_NAME}" "${CHART_ROOT}/${APP_NAME}"
            cat "${CHART_ROOT}/${CHART_NAME}/Chart.yaml" | \
                yq w - name "${APP_NAME}" | \
                yq w - version "1.0.0-rc${IMAGE_VERSION}" > "${CHART_ROOT}/${APP_NAME}/Chart.yaml"
          else
            echo "Chart name and image name match: ${APP_NAME}"
          fi

          CHART_PATH="${CHART_ROOT}/${APP_NAME}"

          RELEASE_NAME="${APP_NAME}"
          echo "RELEASE_NAME: $RELEASE_NAME"

          echo $(helm version)

          echo "CHECKING CHART (lint)"
          helm lint ${CHART_PATH}

          PREFIX=""
          if [[ -f "${CHART_PATH}/requirements.yaml" ]] || grep -Eq "^dependencies:" "${CHART_PATH}/Chart.yaml"; then
              DEPENDENCY_FILE="${CHART_PATH}/Chart.yaml"
              if [[ -f "${CHART_PATH}/requirements.yaml" ]]; then
                  DEPENDENCY_FILE="${CHART_PATH}/requirements.yaml"
              fi

              PREFIX="$(yq r -j "${DEPENDENCY_FILE}" | jq -r '.dependencies | .[] | .alias // .name' | head -1)."
          fi

          # Update helm chart with repository and tag values
          cat ${CHART_PATH}/values.yaml | \
              yq w - "${PREFIX}nameOverride" "${APP_NAME}" | \
              yq w - "${PREFIX}fullnameOverride" "${APP_NAME}" | \
              yq w - "${PREFIX}vcsInfo.repoUrl" "${GIT_URL}" | \
              yq w - "${PREFIX}vcsInfo.branch" "${GIT_REVISION}" | \
              yq w - "${PREFIX}image.repository" "${IMAGE_URL}" | \
              yq w - --style single "${PREFIX}image.tag" "${IMAGE_VERSION}" | \
              yq w - "${PREFIX}ingress.enabled" "${INGRESS_ENABLED}" | \
              yq w - "${PREFIX}route.enabled" "${ROUTE_ENABLED}" > ./values.yaml.tmp
          cp ./values.yaml.tmp ${CHART_PATH}/values.yaml
          cat ${CHART_PATH}/values.yaml

          helm dep update "${CHART_PATH}"

          # Using 'upgrade --install" for rolling updates. Note that subsequent updates will occur in the same namespace the release is currently deployed in, ignoring the explicit--namespace argument".
          helm template ${RELEASE_NAME} ${CHART_PATH} \
              --namespace ${APP_NAMESPACE} \
              --set ${PREFIX}ingress.tlsSecretName="${TLS_SECRET_NAME}" \
              --set ${PREFIX}ingress.subdomain="${INGRESS_SUBDOMAIN}" > ./release.yaml

          echo -e "Generated release yaml for: ${APP_NAMESPACE}/${APP_NAME}"
          cat ./release.yaml

          echo -e "Deploying into: ${APP_NAMESPACE}/${APP_NAME}"
          kubectl apply -n ${APP_NAMESPACE} -f ./release.yaml --validate=false > results.out
          cat results.out
          echo "Waiting for rollout of ${APP_NAMESPACE}/${APP_NAME}"


          cat results.out | \
            grep -E "deployment|statefulset|integrationserver|queuemanager" | \
            sed "s/deployment.apps/deployment/g" | \
            sed "s/statefulset.apps/statefulset/g" | \
            sed "s/configured//g" | \
            sed "s/created//g" | \
            sed "s/unchanged//g" | while read target; do
            echo "Waiting for rollout of ${target} in ${APP_NAMESPACE}"
            if [[ ${target} == *"integrationserver"* ]]; then
              kubectl wait --timeout=-1s --for=condition=Ready ${target}
            elif [[ ${target} == *"queuemanager"* ]]; then
              until [[ "$(kubectl get ${target} -o 'jsonpath={.status.phase}')" = "Running" ]];
              do
              sleep 5
              echo "Waiting for Queuemanager to be ready."
              done
            else
              kubectl rollout status -n ${APP_NAMESPACE} ${target}
              SERVICE_PORT=$(kubectl get svc "${APP_NAME}" -n "${APP_NAMESPACE}" -o jsonpath="{.spec.ports[?(@.name == 'http')].port}")
              echo -n "${SERVICE_PORT}" | tee $(results.service-port.path)
            fi
            echo -n "${target}" | cut -f1 -d / | tee $(results.resource-type.path)
          done

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-setup-v2-6-13
  annotations:
    description: Sets up the pipeline environment and generates/normalizes a number of param values
    app.openshift.io/description: Sets up the pipeline environment and generates/normalizes a number of param values
    app.openshift.io/vcs-ref: master
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: source-dir
      default: /source
    - name: image-url
      description: The dev image (use image-release for released image)
      default: ""
    - name: image-server
      description: The dev image registry server if params.image-url not provided
      default: ""
    - name: image-namespace
      description: The dev image registry namespace if params.image-url not provided
      default: ""
    - name: image-repository
      description: The dev image registry repository/imagename if params.image-url not provided
      default: ""
    - name: image-tag
      description: The dev image registry tag if params.image-url not provided
      default: ""
    - name: image-release
      description: The url of final released image
      default: ""
    - name: app-namespace
      description: The openshift/kubernetes namespace to deploy dev app
      default: ""
    - name: app-name
      description: The app name to be use in openshift/kuberentes deployment and helm chart
      default: ""
    - name: deploy-ingress-type
      default: "route"
    - name: health-protocol
      default: "https"
    - name: health-endpoint
      description: Endpoint to check health after deployment, liberty uses / not /health
      default: "/health"
    - name: health-url
      description: Override for health check url
      default: ""
    - name: health-curl
      description: Override for health check curl flags
      default: "-k"
    - name: scan-image
      description: Flag indicating that a Vulnerability Advisor scan should be performed
      default: "false"
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
    - name: js-image
      default: quay.io/ibmgaragecloud/node:lts-stretch
    - name: ace-project
      description: Name of the ACE Toolkit project
      default: ""
    - name: lint-dockerfile
      description: Flag indication that Dockerfile will be linted
      default: "true"
  results:
    - name: git-url
    - name: git-revision
    - name: source-dir
    - name: image-url
    - name: image-server
    - name: image-namespace
    - name: image-repository
    - name: image-tag
    - name: image-release
    - name: app-namespace
    - name: app-name
    - name: deploy-ingress-type
    - name: health-protocol
    - name: health-endpoint
    - name: health-url
    - name: health-curl
    - name: tools-image
    - name: js-image
    - name: scan-image
    - name: scan-trivy
    - name: scan-ibm
    - name: ace-project
    - name: dockerfile-lint
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
        - name: REGISTRY_RELEASE_SERVER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_URL
              optional: true
        - name: REGISTRY_RELEASE_NAMESPACE
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_NAMESPACE
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            git clone $(params.git-url) $(params.source-dir)
        fi
        cd $(params.source-dir)
        git checkout $(params.git-revision)

        # Results
        # Defaults
        echo -n "$(params.git-url)">$(results.git-url.path)
        echo -n "$(git rev-parse --verify HEAD)">$(results.git-revision.path)
        echo -n "$(params.source-dir)">$(results.source-dir.path)
        echo -n "$(params.app-namespace)">$(results.app-namespace.path)
        echo -n "$(params.app-name)">$(results.app-name.path)
        echo -n "$(params.deploy-ingress-type)">$(results.deploy-ingress-type.path)
        echo -n "$(params.health-protocol)">$(results.health-protocol.path)
        echo -n "$(params.health-endpoint)">$(results.health-endpoint.path)
        echo -n "$(params.health-url)">$(results.health-url.path)
        echo -n "$(params.health-curl)">$(results.health-curl.path)
        echo -n "$(params.tools-image)">$(results.tools-image.path)
        echo -n "$(params.js-image)">$(results.js-image.path)
        echo -n "$(params.ace-project)">$(results.ace-project.path)


        REGISTRY_SERVER="$(params.image-server)"
        REGISTRY_NAMESPACE="$(params.image-namespace)"
        REGISTRY_REPOSITORY="$(params.image-repository)"
        REGISTRY_TAG="$(params.image-tag)"

        if [[ -n "$(params.image-url)" ]]; then
          REGISTRY_SERVER_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $1}')
          if [[ -n "${REGISTRY_SERVER_VALUE}" ]]; then
            REGISTRY_SERVER="${REGISTRY_SERVER_VALUE}"
          fi

          REGISTRY_NAMESPACE_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $2}')
          if [[ -n "${REGISTRY_NAMESPACE_VALUE}" ]]; then
            if [[ "${REGISTRY_NAMESPACE_VALUE}" = '$NAMESPACE' ]]; then
              REGISTRY_NAMESPACE=${NAMESPACE}
            else
              REGISTRY_NAMESPACE="${REGISTRY_NAMESPACE_VALUE}"
            fi
          fi

          REGISTRY_REPOSITORY_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $3}' |  awk -F : '{print $1}')
          if [[ -n "${REGISTRY_REPOSITORY_VALUE}" ]]; then
            REGISTRY_REPOSITORY="${REGISTRY_REPOSITORY_VALUE}"
          fi

          REGISTRY_TAG_VALUE=$(echo "$(params.image-url)" | awk -F / '{print $3}' | awk -F : '{print $2}')
          if [[ -n "${REGISTRY_TAG_VALUE}" ]]; then
            REGISTRY_TAG="${REGISTRY_TAG_VALUE}"
          fi
        fi

        if [[ -z "${REGISTRY_SERVER}" ]]; then
          # Assume is internal
          REGISTRY_SERVER="image-registry.openshift-image-registry.svc:5000"
        fi
        if [[ -z "${REGISTRY_NAMESPACE}" ]]; then
          # Assume current k8s namespace
          REGISTRY_NAMESPACE="${NAMESPACE}"
        fi
        if [[ -z "${REGISTRY_REPOSITORY}" ]]; then
          # Assume repo dir is image repository/image-name
          REGISTRY_REPOSITORY="$(basename $(echo -n $(git config --get remote.origin.url)) .git | tr '[:upper:]' '[:lower:]' | sed 's/_/-/g')"
        fi
        if [[ -z "${REGISTRY_TAG}" ]]; then
          # Assume short git commit revision
          REGISTRY_TAG="$(git rev-parse --verify HEAD --short)"
        fi
        echo -n "${REGISTRY_SERVER}">$(results.image-server.path)
        echo -n "${REGISTRY_NAMESPACE}">$(results.image-namespace.path)
        echo -n "${REGISTRY_REPOSITORY}">$(results.image-repository.path)
        echo -n "${REGISTRY_TAG}">$(results.image-tag.path)
        echo -n "${REGISTRY_SERVER}/${REGISTRY_NAMESPACE}/${REGISTRY_REPOSITORY}:${REGISTRY_TAG}">$(results.image-url.path)

        if [[ -z "$(params.app-namespace)" ]]; then
          # Assume current namespace
          echo -n "${NAMESPACE}">$(results.app-namespace.path)
        fi

        if [[ -z "$(params.app-name)" ]]; then
          # Assume image repository/name
          echo -n "${REGISTRY_REPOSITORY}">$(results.app-name.path)
        fi


        if [[ -n "$(params.image-release)" ]]; then
          REGISTRY_RELEASE_SERVER_VALUE=$(echo "$(params.image-release)" | awk -F / '{print $1}')
          if [[ -n "${REGISTRY_RELEASE_SERVER_VALUE}" ]]; then
            REGISTRY_RELEASE_SERVER="${REGISTRY_RELEASE_SERVER_VALUE}"
          fi

          REGISTRY_RELEASE_NAMESPACE_VALUE=$(echo "$(params.image-release)" | awk -F / '{print $2}')
          if [[ -n "${REGISTRY_RELEASE_NAMESPACE_VALUE}" ]]; then
            if [[ "${REGISTRY_RELEASE_NAMESPACE_VALUE}" = '$NAMESPACE' ]]; then
              REGISTRY_RELEASE_NAMESPACE=${NAMESPACE}
            else
              REGISTRY_RELEASE_NAMESPACE="${REGISTRY_RELEASE_NAMESPACE_VALUE}"
            fi
          elif [[ "${REGISTRY_RELEASE_SERVER}" = "image-registry.openshift-image-registry.svc:5000" ]]; then
            REGISTRY_RELEASE_NAMESPACE=${NAMESPACE}
          fi
        fi
        if [[ -z "${REGISTRY_RELEASE_NAMESPACE}" ]]; then
          # Assume current k8s namespace
          REGISTRY_RELEASE_NAMESPACE="${NAMESPACE}"
        fi
        if [[ -z "${REGISTRY_RELEASE_SERVER}" ]]; then
          # Assume internal registry
          REGISTRY_RELEASE_SERVER="image-registry.openshift-image-registry.svc:5000"
        fi
        REGISTRY_RELEASE_URL="${REGISTRY_RELEASE_SERVER}/${REGISTRY_RELEASE_NAMESPACE}/${REGISTRY_REPOSITORY}"
        echo -n "${REGISTRY_RELEASE_URL}">$(results.image-release.path)

        PERFORM_SCAN="$(params.scan-image)"
        PERFORM_SCAN_IBM="false"
        PERFORM_SCAN_TRIVY="false"
        if [[ "${PERFORM_SCAN}" == "true" ]]; then
          echo "User selected to perform container image scanning"
          if echo "$REGISTRY_RELEASE_URL" | grep 'icr.io'; then
            echo "Using IBM Container registry, enabling scanning using VA"
            PERFORM_SCAN_IBM="true"
          else
            echo "Not using IBM Container registry, enabling scanning using trivy"
            PERFORM_SCAN_TRIVY="true"
          fi
        fi

        echo -n "${PERFORM_SCAN}">$(results.scan-image.path)
        echo -n "${PERFORM_SCAN_TRIVY}">$(results.scan-trivy.path)
        echo -n "${PERFORM_SCAN_IBM}">$(results.scan-ibm.path)

        if [[ -z "$(params.ace-project)" ]]; then
          # Retrieve name of ACE Toolkit project
          ACE_PROJECT=$(ls workspace || true)
          echo -n "${ACE_PROJECT}">$(results.ace-project.path)
        fi

        PERFORM_LINT="$(params.lint-dockerfile)"
        echo -n "${PERFORM_LINT}">$(results.dockerfile-lint.path)

        for f in /tekton/results/*; do echo "results.$(basename $f)=$(cat $f)"; done

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-java-maven-test-v2-6-13
  annotations:
    description: Executes build, test, and sonarscan logic for a Java maven application
    app.openshift.io/description: Executes build, test, and sonarscan logic for a Java maven application
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: app-name
      default: "my-java-maven-app"
    - name: maven-image
      default: quay.io/ibmgaragecloud/maven:3.6.3-jdk-11-slim
    - name: sonarqube-java-bin-path
      default: target
    - name: sonarqube-cli
      default: quay.io/ibmgaragecloud/sonarsource-sonar-scanner-cli
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: build
      image: $(params.maven-image)
      workingDir: $(params.source-dir)
      script: |
        if [[ -f "./mvnw" ]]; then
          ./mvnw package
        else
          mvn package
        fi
    - name: test
      image: $(params.maven-image)
      workingDir: $(params.source-dir)
      script: |
        if [[ -f "./mvnw" ]]; then
          ./mvnw test
        else
          mvn test
        fi
    - name: sonar-scan
      image: $(params.sonarqube-cli)
      workingDir: $(params.source-dir)
      env:
        - name: SONAR_USER_HOME
          value: $(params.source-dir)
        - name: SONARQUBE_URL
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_URL
              optional: true
        - name: SONARQUBE_USER
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_USER
              optional: true
        - name: SONARQUBE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sonarqube-access
              key: SONARQUBE_PASSWORD
              optional: true
      script: |
          APP_NAME=$(params.app-name)
          SONARQUBE_JAVA_BINARIES_PATH="$(params.sonarqube-java-bin-path)"

          if ! command -v sonar-scanner &> /dev/null
          then
              echo "Skipping SonarQube step, no task defined"
              exit 0
          fi

          if [ -n "${SONARQUBE_URL}" ]; then

            sonar-scanner \
            -Dsonar.login=${SONARQUBE_USER} \
            -Dsonar.password=${SONARQUBE_PASSWORD} \
            -Dsonar.host.url=${SONARQUBE_URL} \
            -Dsonar.projectKey=${APP_NAME} \
            -Dsonar.java.binaries=${SONARQUBE_JAVA_BINARIES_PATH}

          else
              echo "Skipping Sonar Qube step for now but include"
          fi

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-helm-release-v2-6-13
  annotations:
    description: Publishes the helm chart to the helm repository using the version provided in the image-url
    app.openshift.io/description: Publishes the helm chart to the helm repository using the version provided in the image-url
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: git-url
    - name: git-revision
      default: master
    - name: source-dir
      default: /source
    - name: image-url
      default: ""
    - name: app-name
      default: ""
    - name: deploy-ingress-type
      default: "route"
    - name: helm-curl
      default: ""
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  results:
    - name: helm-url
      description: The url of the helm repository
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: git-clone
      image: quay.io/ibmgaragecloud/alpine-git
      env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout $(params.git-revision)
    - name: package-helm
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: TLS_SECRET_NAME
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: TLS_SECRET_NAME
              optional: true
        - name: INGRESS_SUBDOMAIN
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: INGRESS_SUBDOMAIN
              optional: true
        - name: ARTIFACTORY_URL
          valueFrom:
            secretKeyRef:
              name: artifactory-access
              key: ARTIFACTORY_URL
              optional: true
        - name: ARTIFACTORY_USER
          valueFrom:
            secretKeyRef:
              name: artifactory-access
              key: ARTIFACTORY_USER
              optional: true
        - name: ARTIFACTORY_ENCRYPT
          valueFrom:
            secretKeyRef:
              name: artifactory-access
              key: ARTIFACTORY_ENCRYPT
              optional: true
        - name: ARTIFACTORY_REPOSITORY_KEY
          valueFrom:
            secretKeyRef:
              name: artifactory-access
              key: ARTIFACTORY_REPOSITORY_KEY
              optional: true
        - name: HELM_URL
          valueFrom:
            secretKeyRef:
              name: helm-access
              key: HELM_URL
              optional: true
        - name: HELM_USER
          valueFrom:
            secretKeyRef:
              name: helm-access
              key: HELM_USER
              optional: true
        - name: HELM_PASSWORD
          valueFrom:
            secretKeyRef:
              name: helm-access
              key: HELM_PASSWORD
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex

          CURL_FLAGS="$(params.helm-curl)"

          echo "1. Package Helm Chart"

          GIT_URL="$(params.git-url)"
          GIT_REVISION="$(params.git-revision)"

          IMAGE_SERVER="$(echo "$(params.image-url)" | awk -F / '{print $1}')"
          IMAGE_NAMESPACE="$(echo "$(params.image-url)" | awk -F / '{print $2}')"
          IMAGE_REPOSITORY="$(echo "$(params.image-url)" | awk -F / '{print $3}' | awk -F : '{print $1}')"
          IMAGE_VERSION="$(echo "$(params.image-url)" | awk -F / '{print $3}' | awk -F : '{print $2}')"
          IMAGE_URL="${IMAGE_SERVER}/${IMAGE_NAMESPACE}/${IMAGE_REPOSITORY}"

          APP_NAME="$(params.app-name)"
          if [[ -z "${APP_NAME}" ]]; then
            APP_NAME="${IMAGE_REPOSITORY}"
          fi

          INGRESS_TYPE="$(params.deploy-ingress-type)"
          if [[ "${INGRESS_TYPE}" == "route" ]]; then
            ROUTE_ENABLED="true"
            INGRESS_ENABLED="false"
          else
            ROUTE_ENABLED="false"
            INGRESS_ENABLED="true"
          fi

          export CHART_ROOT=$(find . -name chart)
          echo "CHART_ROOT: $CHART_ROOT"

          export CHART=$(find . -name Chart*.yaml)
          echo "CHART: $CHART"

          export CHART_NAME=$(cat $CHART | yq r - name)
          echo "CHART_NAME: $CHART_NAME"

          # Update Chart name and version
          if [[ "${CHART_NAME}" != "${APP_NAME}" ]]; then
            echo "Renaming chart from ${CHART_NAME} to ${APP_NAME}"
            cp -R "${CHART_ROOT}/${CHART_NAME}" "${CHART_ROOT}/${APP_NAME}"
            cat "${CHART_ROOT}/${CHART_NAME}/Chart.yaml" | \
                yq w - name "${APP_NAME}" | \
                yq w - version "${IMAGE_VERSION}" > "${CHART_ROOT}/${APP_NAME}/Chart.yaml"
          else
            echo "Chart name and image name match: ${APP_NAME}"
          fi

          CHART_PATH="${CHART_ROOT}/${APP_NAME}"

          echo ""
          echo "Chart ${CHART_PATH}"
          cat ${CHART_PATH}/Chart.yaml

          RELEASE_NAME="${APP_NAME}"
          echo "RELEASE_NAME: $RELEASE_NAME"

          echo $(helm version)

          PREFIX=""
          if [[ -f "${CHART_PATH}/requirements.yaml" ]] || grep -Eq "^dependencies:" "${CHART_PATH}/Chart.yaml"; then
              DEPENDENCY_FILE="${CHART_PATH}/Chart.yaml"
              if [[ -f "${CHART_PATH}/requirements.yaml" ]]; then
                  DEPENDENCY_FILE="${CHART_PATH}/requirements.yaml"
              fi

              PREFIX="$(yq r -j "${DEPENDENCY_FILE}" | jq -r '.dependencies | .[] | .alias // .name' | head -1)."
          fi

          # Update helm chart with repository and tag values
          cat ${CHART_PATH}/values.yaml | \
              yq w - "${PREFIX}nameOverride" "${APP_NAME}" | \
              yq w - "${PREFIX}fullnameOverride" "${APP_NAME}" | \
              yq w - "${PREFIX}vcsInfo.repoUrl" "${GIT_URL}" | \
              yq w - "${PREFIX}vcsInfo.branch" "${GIT_REVISION}" | \
              yq w - "${PREFIX}image.repository" "${IMAGE_URL}" | \
              yq w - "${PREFIX}image.tag" "${IMAGE_VERSION}" | \
              yq w - "${PREFIX}ingress.enabled" "${INGRESS_ENABLED}" | \
              yq w - "${PREFIX}route.enabled" "${ROUTE_ENABLED}" > ./values.yaml.tmp
          cp ./values.yaml.tmp ${CHART_PATH}/values.yaml
          cat ${CHART_PATH}/values.yaml

          echo "CHECKING CHART (lint)"
          helm lint ${CHART_PATH}


          echo "2. Publish Helm Chart"

          if [[ -z "${HELM_URL}" ]] && [[ -z "${HELM_USER}" ]]; then
            if [[ -z "${ARTIFACTORY_URL}" ]]; then
              echo "It looks like Artifactory has not been installed (ARTIFACTORY_URL from artifactory-acess secret is missing). Skipping step."
              exit 0
            fi

            set +x
            if [[ -z "${ARTIFACTORY_USER}" ]]; then
              echo "Something's wrong... The Artifactory url is configured but the Artifactory credentials cannot be found. Check your artifactory-access secret."
              exit 1
            fi

            if [[ -z "${ARTIFACTORY_ENCRYPT}" ]]; then
                echo "It looks like your Artifactory installation is not complete. Please complete the steps found here - http://ibm.biz/complete-setup"
                exit 1
            fi

            HELM_USER="${ARTIFACTORY_USER}"
            set +x
            HELM_PASSWORD="${ARTIFACTORY_ENCRYPT}"
            set -x

            if [[ -z "${ARTIFACTORY_REPOSITORY_KEY}" ]]; then
              ARTIFACTORY_REPOSITORY_KEY="generic-local"
            fi

            if [[ -z "${HELM_URL}" ]]; then
              HELM_URL="${ARTIFACTORY_URL}/artifactory/${ARTIFACTORY_REPOSITORY_KEY}"
            fi

          fi

          export CHART_ROOT=$(find . -name chart)
          echo "CHART_ROOT: $CHART_ROOT"

          export CHART_NAME="${APP_NAME}"
          echo "CHART_NAME: $CHART_NAME"

          CHART_PATH="${CHART_ROOT}/${CHART_NAME}"

          helm dep update "${CHART_PATH}"

          # Package Helm Chart
          helm package --version ${IMAGE_VERSION} ${CHART_PATH}

          # Get the index and re index it with current Helm Chart
          set +x
          echo "curl ${CURL_FLAGS} -u${HELM_USER}:xxxx -O ${HELM_URL}/${IMAGE_NAMESPACE}/index.yaml"
          curl ${CURL_FLAGS} -u${HELM_USER}:${HELM_PASSWORD} -O "${HELM_URL}/${IMAGE_NAMESPACE}/index.yaml"
          set -x

          apiVersion=$(grep apiVersion ./index.yaml | sed -E "s/apiVersion: (.*)/\1/g")
          if [[ $(cat index.yaml | jq '.errors[0].status') != "404" ]] && [[ -n "${apiVersion}" ]]; then
              # Merge the chart index with the current index.yaml held in Artifactory
              echo "Merging Chart into index.yaml for Chart Repository"
              helm repo index . --url ${HELM_URL}/${IMAGE_NAMESPACE} --merge index.yaml
          else
              # Dont Merge this is first time one is being created
              echo "Creating a new index.yaml for Chart Repository"
              rm index.yaml
              helm repo index . --url ${HELM_URL}/${IMAGE_NAMESPACE}
          fi;

          # Persist the Helm Chart in Helm repo for us by ArgoCD
          set +x
          echo "curl ${CURL_FLAGS} -u${HELM_USER}:xxxx -s -T ${CHART_NAME}-${IMAGE_VERSION}.tgz ${HELM_URL}/${IMAGE_NAMESPACE}/${CHART_NAME}-${IMAGE_VERSION}.tgz"
          curl ${CURL_FLAGS} -u${HELM_USER}:${HELM_PASSWORD} -s -T ${CHART_NAME}-${IMAGE_VERSION}.tgz "${HELM_URL}/${IMAGE_NAMESPACE}/${CHART_NAME}-${IMAGE_VERSION}.tgz"

          # Persist the Helm Index in the helm repo for us by ArgoCD
          echo "curl ${CURL_FLAGS} -u${HELM_USER}:xxxx -s -T index.yaml ${HELM_URL}/${IMAGE_NAMESPACE}/index.yaml"
          curl ${CURL_FLAGS} -u${HELM_USER}:${HELM_PASSWORD} -s -T index.yaml "${HELM_URL}/${IMAGE_NAMESPACE}/index.yaml"

          echo -n "${HELM_URL}/${IMAGE_NAMESPACE}" | tee $(results.helm-url.path)



---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-operator-gitops-v2-6-13
  annotations:
    description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: app-name
      default: ""
    - name: version
      default: ""
    - name: source-dir
      default: /source
    - name: subdir
      default: ""
    - name: parentdir
      default: ""
    - name: image-url
      default: ""
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: gitops
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: HOME
          value: /home/devops
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME_CD
          valueFrom:
            secretKeyRef:
              name: olm-catalog-secret
              key: username
              optional: true
        - name: GIT_PASSWORD_CD
          valueFrom:
            secretKeyRef:
              name: olm-catalog-secret
              key: password
              optional: true
        - name: GIT_PARENT_DIR
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: parentdir
              optional: true
        - name: GIT_PROTOCOL
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: protocol
              optional: true
        - name: GIT_HOST
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: host
              optional: true
        - name: GIT_ORG
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: org
              optional: true
        - name: GIT_REPO
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: repo
              optional: true
        - name: GIT_BRANCH
          valueFrom:
            configMapKeyRef:
              name: olm-catalog-repo
              key: branch
              optional: true
      script: |
        #!/usr/bin/env bash
        set -ex

        APP_NAME="$(params.app-name)"

        if [[ -n "$(params.parentdir)" ]]; then
          PARENT_DIR="$(params.parentdir)"
        elif [[ -n "${GIT_PARENT_DIR}" ]] && [[ "${GIT_PARENT_DIR}" = "bash -c"* ]]; then
          PARENT_DIR=$(eval $GIT_PARENT_DIR | tail -n 1)
        elif [[ -n "${GIT_PARENT_DIR}" ]]; then
          PARENT_DIR="${GIT_PARENT_DIR}"
        else
          PARENT_DIR="."
        fi

        if [[ -n "$(params.subdir)" ]]; then
          SUBDIR="${PARENT_DIR}/$(params.subdir)"
        else
          SUBDIR="${PARENT_DIR}"
        fi


        PROTOCOL="${GIT_PROTOCOL}"
        if [[ -z "${PROTOCOL}" ]]; then
          PROTOCOL="https"
        fi

        VERSION="$(params.version)"
        BUNDLE_URL="$(params.image-url)"

        if [[ -z "${GIT_HOST}" ]] || [[ -z "${GIT_ORG}" ]] || [[ -z "${GIT_REPO}" ]]; then
            echo "GitOps repo has not been configured with confimap gitops-repo. Skipping trigger step"
            exit 0
        fi

        set +x
        if [[ -n "${GIT_USERNAME_CD}" ]]; then
          GIT_AUTH_USER="${GIT_USERNAME_CD}"
          GIT_AUTH_PWD="${GIT_PASSWORD_CD}"
        elif [[ -n "${GIT_USERNAME}" ]]; then
          GIT_AUTH_USER="${GIT_USERNAME}"
          GIT_AUTH_PWD="${GIT_PASSWORD}"
        else
          echo "Credentials for GitOps repo not set in secret gitops-cd-secret or git-credentials"
          exit 1
        fi
        set -x

        BRANCH_CMD=""
        if [[ -n "${GIT_BRANCH}" ]]; then
          BRANCH_CMD="-b ${GIT_BRANCH}"
        fi

        git config --global user.email "gitops@cloudnativetoolkit.dev"
        git config --global user.name "Cloud Native Toolkit Pipeline"
        echo "git clone ${BRANCH_CMD} ${PROTOCOL}://${GIT_AUTH_USER}:xxxx@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
        set +x
        GIT_URL="${PROTOCOL}://${GIT_AUTH_USER}:${GIT_AUTH_PWD}@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
        git clone ${BRANCH_CMD} ${GIT_URL} gitops_cd
        set -x
        cd gitops_cd

        BUNDLE_METADATA="bundles.txt"
        if [[ -n "${SUBDIR}" ]]; then
          # create directory
          mkdir -p "${SUBDIR}"
        fi
        if [[ -d "${SUBDIR}" ]]; then
          BUNDLE_METADATA="${SUBDIR}/${BUNDLE_METADATA}"
        fi

        touch ${BUNDLE_METADATA}
        if ! grep -qE "${BUNDLE_URL}:${VERSION}$" ${BUNDLE_METADATA}; then
          echo "${BUNDLE_URL}:${VERSION}" >> ${BUNDLE_METADATA}
        fi

        if [[ $(git status -s | wc -l) -eq 0 ]]; then
          echo "No changes"
          exit 0
        fi

        git add ${BUNDLE_METADATA}
        git commit -m "Updates ${APP_NAME} to ${VERSION}"
        git push -v

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-img-scan-v2-6-13
  annotations:
    description: Runs an image scan with Trivy or IBM VA and fails the build if issues are found.
    app.openshift.io/description: Runs an image scan with Trivy or IBM VA and fails the build if issues are found.
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: image-url
      description: "The location of image to scan on IBM Container Registry <server>/<namespace>/<repository>:<tag>"
    - name: scan-trivy
      description: Flag indicating that a scan should be performed with Trivy
      default: "false"
    - name: scan-ibm
      description: Flag indicating that a scan should be performed with IBM VA
      default: "false"
    - name: SKOPEO_IMAGE
      default: quay.io/containers/skopeo:v1.1.0
    - name: IMAGE_FROM_TLS_VERIFY
      default: "false"
    - name: TRIVY_IMAGE
      default: quay.io/ibmgaragecloud/aquasec-trivy
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  volumes:
    - name: oci-image
      emptyDir: {}
  steps:
    - name: trivy-pull
      image: $(params.SKOPEO_IMAGE)
      env:
        - name: REGISTRY_USER
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_USER
              optional: true
        - name: REGISTRY_PASSWORD
          valueFrom:
            secretKeyRef:
              name: registry-access
              key: REGISTRY_PASSWORD
              optional: true
      volumeMounts:
        - mountPath: /var/oci
          name: oci-image
      securityContext:
        privileged: true
      script: |
        set -ex
        PERFORM_SCAN="$(params.scan-trivy)"
        if [[ "${PERFORM_SCAN}" == "false" ]] || [[ -z "${PERFORM_SCAN}" ]]; then
          echo "User selected to skip scanning. Skipping Trivy scan."
          exit 0
        fi
        IMAGE_FROM=$(params.image-url)
        REGISTRY_SERVER_FROM=$(echo "${IMAGE_FROM}" | awk -F / '{print $1}')
        IMAGE_TO="oci:/var/oci/image"
        IMAGE_FROM_TLS_VERIFY=$(params.IMAGE_FROM_TLS_VERIFY)
        echo "Tagging ${IMAGE_FROM} as ${IMAGE_TO}"
        set +x
        if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ "${REGISTRY_SERVER_FROM}" != "image-registry.openshift-image-registry.svc:5000" ]]; then
          IMAGE_FROM_CREDS="--src-creds ${REGISTRY_USER}:${REGISTRY_PASSWORD}"
        fi
        set -x
        if [ "${REGISTRY_SERVER_FROM}" =~ ":" ]; then
          IMAGE_FROM_TLS_VERIFY="false"
        fi
        echo "skopeo copy --src-creds=xxxx --src-tls-verify=${IMAGE_FROM_TLS_VERIFY} docker://${IMAGE_FROM} ${IMAGE_TO}"
        set +x
        skopeo copy ${IMAGE_FROM_CREDS} --src-tls-verify=${IMAGE_FROM_TLS_VERIFY} docker://${IMAGE_FROM} ${IMAGE_TO}
    - name: trivy-scan
      image: $(params.TRIVY_IMAGE)
      volumeMounts:
        - mountPath: /var/oci
          name: oci-image
      script: |
          set -ex
          PERFORM_SCAN="$(params.scan-trivy)"
          if [[ "${PERFORM_SCAN}" == "false" ]] || [[ -z "${PERFORM_SCAN}" ]]; then
            echo "User selected to skip scanning. Skipping Trivy scan."
            exit 0
          fi
          PATH_TO_IMAGE="/var/oci/image"
          echo -e "Trivy Security Scan image in registry"
          trivy image --exit-code 0 --input ${PATH_TO_IMAGE}
          trivy image --exit-code 1 --severity CRITICAL --input ${PATH_TO_IMAGE}
          my_exit_code=$?
          echo "Scan exit code :--- $my_exit_code"
          if [ ${my_exit_code} == 1 ]; then
              echo "Trivy scanning completed. CRITICAL Vulnerabilities found."
              exit 1
          else
            echo "Trivy scanning completed. CRITICAL vulnerabilities not found."
          fi
    - name: ibm-scan
      image: $(params.tools-image)
      env:
        - name: HOME
          value: /home/devops
        - name: IBM_CLOUD_APIKEY
          valueFrom:
            secretKeyRef:
              key: APIKEY
              name: ibmcloud-apikey
              optional: true
        - name: IBM_CLOUD_REGION
          valueFrom:
            configMapKeyRef:
              name: ibmcloud-config
              key: REGION
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex
          PERFORM_SCAN="$(params.scan-ibm)"
          if [[ "${PERFORM_SCAN}" == "false" ]] || [[ -z "${PERFORM_SCAN}" ]]; then
            echo "User selected to skip scanning. Skipping Vulnerability Advisor validation."
            exit 0
          fi

          IMAGE_URL=$(params.image-url)
          REGISTRY_SERVER=$(echo $(params.image-url) | awk -F / '{print $1}')



          if [[ ! "${REGISTRY_SERVER}" =~ icr.io ]]; then
            echo "The image is not stored in the IBM Cloud Image Registry. Skipping Vulnerability Advisor validation"
            exit 0
          fi


          echo -e "VA Security Scan image in registry"

          echo "Registry URL: ${REGISTRY_SERVER}"

          set +x
          ibmcloud login --apikey ${IBM_CLOUD_APIKEY} -r ${IBM_CLOUD_REGION}
          ibmcloud target -r ${IBM_CLOUD_REGION}
          set -x
          ibmcloud cr namespace-list

          echo "Getting the VA status of ${IMAGE_URL}"

          set +e
          ibmcloud cr va ${IMAGE_URL} --output json | grep -i "Try again later"
          retry=$?
          while [ $retry -eq 0 ]; do
            sleep 30
            echo "Trying again to see if scan is done"
            ibmcloud cr va ${IMAGE_URL} --output json | grep -i "Try again later"
            retry=$?
          done
          set -e
          ibmcloud cr va ${IMAGE_URL} --output json
          echo "Saving results to va-result.json"
          ibmcloud cr va ${IMAGE_URL} --output json > va-result.json
          VA_STATUS=$(cat va-result.json | jq -r '.[].status')

          echo "VA scan status: ${VA_STATUS}"

          if [[ "${VA_STATUS}" == "OK" ]]; then
            echo "VA - No Issues in the image"
            exit 0
          elif [[ $(cat va-result.json | jq -r '.[].vulnerabilities | length') -gt 0 ]]; then
            echo "VA Failure: $(cat va-result.json | jq -r '.[].vulnerabilities | length') vulnerabilities found in the image"
            cat va-result.json | jq -r '.[].vulnerabilities'
            exit 1
          elif [[ $(cat va-result.json | jq -r '.[].configuration_issues | length') -gt 0 ]]; then
            echo "VA Warning - $(cat va-result.json | jq -r '.[].configuration_issues | length') configuration issues found in the image"
            cat va-result.json | jq -r '.[].configuration_issues'
            exit 0
          else
            echo "VA Warning: non-OK status from Vulnerability Advisor ${VA_STATUS}"
            cat va-result.json | jq -r '.[]'
          fi
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: ibm-gitops-v2-6-13
  annotations:
    description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/description: Publishes the helm chart configuration to the provided gitops repo to trigger downstream deployments
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    app.openshift.io/vcs-ref: master
  labels:
    version: 2.6.13
spec:
  params:
    - name: app-name
      default: ""
    - name: version
      default: ""
    - name: source-dir
      default: /source
    - name: subdir
      default: ""
    - name: parentdir
      default: ""
    - name: yaml
      default: "requirements.yaml"
    - name: helm-url
      default: ""
    - name: tools-image
      default: quay.io/ibmgaragecloud/ibmcloud-dev:v2.0.4
  volumes:
    - name: source
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - name: source
        mountPath: $(params.source-dir)
  steps:
    - name: gitops
      image: $(params.tools-image)
      workingDir: $(params.source-dir)
      env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: HOME
          value: /home/devops
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: username
              optional: true
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-credentials
              key: password
              optional: true
        - name: GIT_USERNAME_CD
          valueFrom:
            secretKeyRef:
              name: gitops-cd-secret
              key: username
              optional: true
        - name: GIT_PASSWORD_CD
          valueFrom:
            secretKeyRef:
              name: gitops-cd-secret
              key: password
              optional: true
        - name: GIT_PARENT_DIR
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: parentdir
              optional: true
        - name: GIT_PARENT_DIR_SERVICES
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: parentdir-services
              optional: true
        - name: GIT_PROTOCOL
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: protocol
              optional: true
        - name: GIT_HOST
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: host
              optional: true
        - name: GIT_ORG
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: org
              optional: true
        - name: GIT_REPO
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: repo
              optional: true
        - name: GIT_BRANCH
          valueFrom:
            configMapKeyRef:
              name: gitops-repo
              key: branch
              optional: true
      script: |
          #!/usr/bin/env bash
          set -ex

          APP_NAME="$(params.app-name)"
          SUBDIR="$(params.subdir)"
          if [[ -z "${SUBDIR}" ]]; then
            SUBDIR="${APP_NAME}"
          fi
          if [[ -n "$(params.parentdir)" ]]; then
            PARENT_DIR="$(params.parentdir)"
          elif [[ -n "${GIT_PARENT_DIR_SERVICES}" ]] && [[ "${GIT_PARENT_DIR_SERVICES}" = "bash -c"* ]]; then
            PARENT_DIR=$(eval $GIT_PARENT_DIR_SERVICES | tail -n 1)
          elif [[ -n "${GIT_PARENT_DIR_SERVICES}" ]]; then
            PARENT_DIR="${GIT_PARENT_DIR_SERVICES}"
          elif [[ -n "${GIT_PARENT_DIR}" ]] && [[ "${GIT_PARENT_DIR}" = "bash -c"* ]]; then
            PARENT_DIR=$(eval $GIT_PARENT_DIR | tail -n 1)
          elif [[ -n "${GIT_PARENT_DIR}" ]]; then
            PARENT_DIR="${GIT_PARENT_DIR}"
          else
            PARENT_DIR="."
          fi
          SUBDIR="${PARENT_DIR}/${SUBDIR}"

          PROTOCOL="${GIT_PROTOCOL}"
          if [[ -z "${PROTOCOL}" ]]; then
            PROTOCOL="https"
          fi

          YAML_FILE="$(params.yaml)"
          VERSION="$(params.version)"
          HELM_URL="$(params.helm-url)"

          if [[ -z "${GIT_HOST}" ]] || [[ -z "${GIT_ORG}" ]] || [[ -z "${GIT_REPO}" ]]; then
              echo "GitOps repo has not been configured with confimap gitops-repo. Skipping trigger step"
              exit 0
          fi

          set +x
          if [[ -n "${GIT_USERNAME_CD}" ]]; then
            GIT_AUTH_USER="${GIT_USERNAME_CD}"
            GIT_AUTH_PWD="${GIT_PASSWORD_CD}"
          elif [[ -n "${GIT_USERNAME}" ]]; then
            GIT_AUTH_USER="${GIT_USERNAME}"
            GIT_AUTH_PWD="${GIT_PASSWORD}"
          else
            echo "Credentials for GitOps repo not set in secret gitops-cd-secret or git-credentials"
            exit 1
          fi
          set -x

          BRANCH_CMD=""
          if [[ -n "${GIT_BRANCH}" ]]; then
            BRANCH_CMD="-b ${GIT_BRANCH}"
          fi

          git config --global user.email "gitops@cloudnativetoolkit.dev"
          git config --global user.name "Cloud Native Toolkit Pipeline"
          echo "git clone ${BRANCH_CMD} ${PROTOCOL}://${GIT_AUTH_USER}:xxxx@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
          set +x
          GIT_URL="${PROTOCOL}://${GIT_AUTH_USER}:${GIT_AUTH_PWD}@${GIT_HOST}/${GIT_ORG}/${GIT_REPO}"
          git clone ${BRANCH_CMD} ${GIT_URL} gitops_cd
          set -x
          cd gitops_cd


          if [[ -f "${SUBDIR}/${YAML_FILE}" ]]; then
            echo "Requirements before update"
            cat "${SUBDIR}/${YAML_FILE}"

            yq r "${SUBDIR}/${YAML_FILE}" -j | \
              jq --arg APP_NAME "${APP_NAME}" --arg VERSION "${VERSION}" --arg REPO "${HELM_URL}" '.dependencies |= map((select(.name == $APP_NAME) | .version = $VERSION | .repository = $REPO) // .)' | \
              yq r --prettyPrint - > "${SUBDIR}/${YAML_FILE}.new"

            rm "${SUBDIR}/${YAML_FILE}"
            mv "${SUBDIR}/${YAML_FILE}.new" "${SUBDIR}/${YAML_FILE}"

            echo "Requirements after update"
            cat "${SUBDIR}/${YAML_FILE}"

          elif [[ -n "${HELM_URL}" ]]; then
            echo "Creating first time chart using ${SUBDIR}"
            # create directory
            mkdir -p "${SUBDIR}"

            # WARNING: Do not indent the cat commands below

          cat <<EOF >"${SUBDIR}/Chart.yaml"
          apiVersion: v2
          version: 0.1.0
          name: ${APP_NAME}
          description: Chart to configure ArgoCD with the ${APP_NAME} project and its applications
          EOF

          cat <<EOF >"${SUBDIR}/${YAML_FILE}"
          dependencies:
            - name: ${APP_NAME}
              version: ${VERSION}
              repository: >-
                ${HELM_URL}
          EOF

          cat <<EOF >"${SUBDIR}/values.yaml"
          global: {}
          ${APP_NAME}:
            replicaCount: 1
          EOF


          else
            echo "GitOps repo configured but unable to update application config"
            exit 1
          fi

          if [[ $(git status -s | wc -l) -eq 0 ]]; then
            echo "No changes"
            exit 0
          fi

          git add "${SUBDIR}/"
          git commit -m "Updates ${APP_NAME} to ${VERSION}"
          git push -v

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-ace-bar
  annotations:
    app.openshift.io/runtime: ace
    app.openshift.io/builder: bar
spec:
  params:
  - description: The url for the git repository
    name: git-url
    type: string
  - default: main
    description: The git revision (branch, tag, or sha) that should be built
    name: git-revision
    type: string
  - default: "true"
    description: Enable the pipeline to scan the image for vulnerabilities
    name: scan-image
    type: string
  - name: health-endpoint
    default: "/health"
    description: Endpoint to check health after deployment, liberty uses / not /health
  - name: ace-project
    description: Name of the ACE Toolkit project
    default: ""
  tasks:
  - name: setup
    params:
    - name: git-url
      value: $(params.git-url)
    - name: git-revision
      value: $(params.git-revision)
    - name: scan-image
      value: $(params.scan-image)
    - name: health-endpoint
      value: $(params.health-endpoint)
    - name: health-protocol
      value: "http"
    - name: ace-project
      value: $(params.ace-project)
    taskRef:
      kind: Task
      name: ibm-setup
  - name: build
    params:
    - name: git-url
      value: $(tasks.setup.results.git-url)
    - name: git-revision
      value: $(tasks.setup.results.git-revision)
    - name: source-dir
      value: $(tasks.setup.results.source-dir)
    - name: image-server
      value: $(tasks.setup.results.image-server)
    - name: image-namespace
      value: $(tasks.setup.results.image-namespace)
    - name: image-repository
      value: $(tasks.setup.results.image-repository)
    - name: image-tag
      value: $(tasks.setup.results.image-tag)
    - name: app-name
      value: $(tasks.setup.results.app-name)
    - name: ace-project
      value: $(tasks.setup.results.ace-project)
    runAfter:
    - setup
    taskRef:
      kind: Task
      name: ibm-build-tag-push-ace-bar
  - name: deploy
    params:
    - name: git-url
      value: $(tasks.setup.results.git-url)
    - name: git-revision
      value: $(tasks.setup.results.git-revision)
    - name: source-dir
      value: $(tasks.setup.results.source-dir)
    - name: image-server
      value: $(tasks.setup.results.image-server)
    - name: image-namespace
      value: $(tasks.setup.results.image-namespace)
    - name: image-repository
      value: $(tasks.setup.results.image-repository)
    - name: image-tag
      value: $(tasks.setup.results.image-tag)
    - name: app-namespace
      value: $(tasks.setup.results.app-namespace)
    - name: app-name
      value: $(tasks.setup.results.app-name)
    - name: deploy-ingress-type
      value: $(tasks.setup.results.deploy-ingress-type)
    - name: tools-image
      value: $(tasks.setup.results.tools-image)
    runAfter:
    - build
    taskRef:
      kind: Task
      name: ibm-deploy
  - name: health
    params:
    - name: app-namespace
      value: $(tasks.setup.results.app-namespace)
    - name: app-name
      value: $(tasks.setup.results.app-name)
    - name: deploy-ingress-type
      value: $(tasks.setup.results.deploy-ingress-type)
    - name: health-protocol
      value: $(tasks.setup.results.health-protocol)
    - name: health-endpoint
      value: $(tasks.setup.results.health-endpoint)
    - name: health-url
      value: $(tasks.setup.results.health-url)
    - name: health-curl
      value: $(tasks.setup.results.health-curl)
    - name: tools-image
      value: $(tasks.setup.results.tools-image)
    - name: resource-type
      value: $(tasks.deploy.results.resource-type)
    runAfter:
    - deploy
    taskRef:
      kind: Task
      name: ibm-health-check
  - name: tag-release
    params:
    - name: git-url
      value: $(tasks.setup.results.git-url)
    - name: git-revision
      value: $(tasks.setup.results.git-revision)
    - name: source-dir
      value: $(tasks.setup.results.source-dir)
    - name: js-image
      value: $(tasks.setup.results.js-image)
    runAfter:
    - health
    taskRef:
      kind: Task
      name: ibm-tag-release
  - name: img-release
    params:
    - name: image-from
      value: $(tasks.setup.results.image-url)
    - name: image-to
      value: $(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)
    runAfter:
    - tag-release
    taskRef:
      kind: Task
      name: ibm-img-release
  - name: img-scan
    params:
    - name: image-url
      value: $(tasks.img-release.results.image-url)
    - name: scan-trivy
      value: $(tasks.setup.results.scan-trivy)
    - name: scan-ibm
      value: $(tasks.setup.results.scan-ibm)
    runAfter:
    - img-release
    taskRef:
      kind: Task
      name: ibm-img-scan
  - name: helm-release
    taskRef:
      name: ibm-helm-release-v2-6-13
    runAfter:
      - img-scan
    params:
      - name: git-url
        value: "$(tasks.setup.results.git-url)"
      - name: git-revision
        value: "$(tasks.setup.results.git-revision)"
      - name: source-dir
        value: "$(tasks.setup.results.source-dir)"
      - name: image-url
        value: "$(tasks.img-release.results.image-url)"
      - name: app-name
        value: "$(tasks.setup.results.app-name)"
      - name: deploy-ingress-type
        value: "$(tasks.setup.results.deploy-ingress-type)"
      - name: tools-image
        value: "$(tasks.setup.results.tools-image)"
  - name: gitops
    params:
    - name: app-name
      value: $(tasks.setup.results.app-name)
    - name: version
      value: $(tasks.tag-release.results.tag)
    - name: helm-url
      value: $(tasks.helm-release.results.helm-url)
    - name: tools-image
      value: $(tasks.setup.results.tools-image)
    runAfter:
    - helm-release
    taskRef:
      kind: Task
      name: ibm-gitops

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-mq
  annotations:
    app.openshift.io/runtime: mq
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: smoke-tests-mq
      taskRef:
        name: ibm-smoke-tests-mq-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - smoke-tests-mq
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: gitops
      taskRef:
        name: ibm-gitops-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: helm-url
          value: $(tasks.helm-release.results.helm-url)
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-golang-edge
  annotations:
    app.openshift.io/runtime: golang
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
    - name: lint-dockerfile
      description: Enable the pipeline to lint the Dockerfile for best practices
      default: "true"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
        - name: lint-dockerfile
          value: $(params.lint-dockerfile)
    - name: test
      taskRef:
        name: ibm-golang-test-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
    - name: dockerfile-lint
      taskRef:
        name: ibm-dockerfile-lint-v2-6-13
      runAfter:
        - test
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: lint-dockerfile
          value: "$(tasks.setup.results.dockerfile-lint)"
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - dockerfile-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: deploy
      taskRef:
        name: ibm-deploy-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: health
      taskRef:
        name: ibm-health-check-v2-6-13
      runAfter:
        - deploy
      params:
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: health-protocol
          value: "$(tasks.setup.results.health-protocol)"
        - name: health-endpoint
          value: "$(tasks.setup.results.health-endpoint)"
        - name: health-url
          value: "$(tasks.setup.results.health-url)"
        - name: health-curl
          value: "$(tasks.setup.results.health-curl)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - health
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: edge-cd
      taskRef:
        name: ibm-gitops-edge-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-appmod-liberty
  annotations:
    app.openshift.io/runtime: openjdk
    app.openshift.io/builder: maven
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
    - name: health-endpoint
      description: Endpoint to check health after deployment, liberty uses / not /health
      default: "/"
    - name: java-bin-path
      description: The path to the java binaries. The default value is "target"
      default: target
    - name: lint-dockerfile
      description: Enable the pipeline to lint the Dockerfile for best practices
      default: "true"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
        - name: health-endpoint
          value: $(params.health-endpoint)
        - name: lint-dockerfile
          value: $(params.lint-dockerfile)
    - name: test
      taskRef:
        name: ibm-java-maven-test-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: sonarqube-java-bin-path
          value: "$(params.java-bin-path)"
    - name: dockerfile-lint
      taskRef:
        name: ibm-dockerfile-lint-v2-6-13
      runAfter:
        - test
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: lint-dockerfile
          value: "$(tasks.setup.results.dockerfile-lint)"
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - dockerfile-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: deploy
      taskRef:
        name: ibm-deploy-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: health
      taskRef:
        name: ibm-health-check-v2-6-13
      runAfter:
        - deploy
      params:
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: health-protocol
          value: "$(tasks.setup.results.health-protocol)"
        - name: health-endpoint
          value: "$(tasks.setup.results.health-endpoint)"
        - name: health-url
          value: "$(tasks.setup.results.health-url)"
        - name: health-curl
          value: "$(tasks.setup.results.health-curl)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - health
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: gitops
      taskRef:
        name: ibm-gitops-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: helm-url
          value: $(tasks.helm-release.results.helm-url)
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-nodejs
  annotations:
    app.openshift.io/runtime: nodejs
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
    - name: lint-dockerfile
      description: Enable the pipeline to lint the Dockerfile for best practices
      default: "true"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
        - name: lint-dockerfile
          value: $(params.lint-dockerfile)
    - name: test
      taskRef:
        name: ibm-nodejs-test-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
        - name: app-name
          value: $(tasks.setup.results.app-name)
    - name: dockerfile-lint
      taskRef:
        name: ibm-dockerfile-lint-v2-6-13
      runAfter:
        - test
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: lint-dockerfile
          value: "$(tasks.setup.results.dockerfile-lint)"
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - dockerfile-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: deploy
      taskRef:
        name: ibm-deploy-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: health
      taskRef:
        name: ibm-health-check-v2-6-13
      runAfter:
        - deploy
      params:
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: health-protocol
          value: "$(tasks.setup.results.health-protocol)"
        - name: health-endpoint
          value: "$(tasks.setup.results.health-endpoint)"
        - name: health-url
          value: "$(tasks.setup.results.health-url)"
        - name: health-curl
          value: "$(tasks.setup.results.health-curl)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - health
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: gitops
      taskRef:
        name: ibm-gitops-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: helm-url
          value: $(tasks.helm-release.results.helm-url)
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-general
  annotations:
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
    - name: lint-dockerfile
      description: Enable the pipeline to lint the Dockerfile for best practices
      default: "true"
    - name: health-endpoint
      description: Endpoint to check health after deployment, defaults /
      default: "/"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
        - name: health-endpoint
          value: $(params.health-endpoint)
        - name: lint-dockerfile
          value: $(params.lint-dockerfile)
    - name: code-lint
      taskRef:
        name: ibm-sonar-test-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: app-name
          value: $(tasks.setup.results.app-name)
    - name: dockerfile-lint
      taskRef:
        name: ibm-dockerfile-lint-v2-6-13
      runAfter:
        - code-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: lint-dockerfile
          value: "$(tasks.setup.results.dockerfile-lint)"
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - dockerfile-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: deploy
      taskRef:
        name: ibm-deploy-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: health
      taskRef:
        name: ibm-health-check-v2-6-13
      runAfter:
        - deploy
      params:
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: health-protocol
          value: "$(tasks.setup.results.health-protocol)"
        - name: health-endpoint
          value: "$(tasks.setup.results.health-endpoint)"
        - name: health-url
          value: "$(tasks.setup.results.health-url)"
        - name: health-curl
          value: "$(tasks.setup.results.health-curl)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - health
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: gitops
      taskRef:
        name: ibm-gitops-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: helm-url
          value: $(tasks.helm-release.results.helm-url)
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-golang
  annotations:
    app.openshift.io/runtime: golang
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
    - name: lint-dockerfile
      description: Enable the pipeline to lint the Dockerfile for best practices
      default: "true"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
        - name: lint-dockerfile
          value: $(params.lint-dockerfile)
    - name: test
      taskRef:
        name: ibm-golang-test-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
    - name: dockerfile-lint
      taskRef:
        name: ibm-dockerfile-lint-v2-6-13
      runAfter:
        - test
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: lint-dockerfile
          value: "$(tasks.setup.results.dockerfile-lint)"
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - dockerfile-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: deploy
      taskRef:
        name: ibm-deploy-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: health
      taskRef:
        name: ibm-health-check-v2-6-13
      runAfter:
        - deploy
      params:
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: health-protocol
          value: "$(tasks.setup.results.health-protocol)"
        - name: health-endpoint
          value: "$(tasks.setup.results.health-endpoint)"
        - name: health-url
          value: "$(tasks.setup.results.health-url)"
        - name: health-curl
          value: "$(tasks.setup.results.health-curl)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - health
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: gitops
      taskRef:
        name: ibm-gitops-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: helm-url
          value: $(tasks.helm-release.results.helm-url)
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-java-gradle
  annotations:
    app.openshift.io/runtime: openjdk
    app.openshift.io/builder: gradle
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
    - name: health-endpoint
      default: "/health"
      description: Endpoint to check health after deployment, liberty uses / not /health
    - name: lint-dockerfile
      description: Enable the pipeline to lint the Dockerfile for best practices
      default: "true"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
        - name: health-endpoint
          value: $(params.health-endpoint)
        - name: lint-dockerfile
          value: $(params.lint-dockerfile)
    - name: test
      taskRef:
        name: ibm-java-gradle-test-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
    - name: dockerfile-lint
      taskRef:
        name: ibm-dockerfile-lint-v2-6-13
      runAfter:
        - test
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: lint-dockerfile
          value: "$(tasks.setup.results.dockerfile-lint)"
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - dockerfile-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: deploy
      taskRef:
        name: ibm-deploy-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: health
      taskRef:
        name: ibm-health-check-v2-6-13
      runAfter:
        - deploy
      params:
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: health-protocol
          value: "$(tasks.setup.results.health-protocol)"
        - name: health-endpoint
          value: "$(tasks.setup.results.health-endpoint)"
        - name: health-url
          value: "$(tasks.setup.results.health-url)"
        - name: health-curl
          value: "$(tasks.setup.results.health-curl)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: pact-verify
      taskRef:
        name: ibm-gradle-pact-verify-v2-6-13
      runAfter:
        - health
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: service-host
          value: "$(tasks.setup.results.app-name)"
        - name: service-port
          value: "$(tasks.deploy.results.service-port)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - pact-verify
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: gitops
      taskRef:
        name: ibm-gitops-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: helm-url
          value: $(tasks.helm-release.results.helm-url)
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-operator-catalog
  annotations:
    app.openshift.io/runtime: operator
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "false"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: build
      taskRef:
        name: ibm-operator-catalog-build-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: gitops
      taskRef:
        name: ibm-operator-catalog-gitops-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: image-url
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-operator
  annotations:
    app.openshift.io/runtime: operator
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: operator-bundle
      taskRef:
        name: ibm-operator-bundle-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.setup.results.image-release)"
        - name: image-tag
          value: "$(tasks.tag-release.results.tag)"
    - name: gitops
      taskRef:
        name: ibm-operator-gitops-v2-6-13
      runAfter:
        - operator-bundle
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: image-url
          value: "$(tasks.operator-bundle.results.bundle-image-url)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: ibm-java-maven
  annotations:
    app.openshift.io/runtime: openjdk
    app.openshift.io/builder: maven
spec:
  params:
    - name: git-url
      description: The url for the git repository
    - name: git-revision
      description: The git revision (branch, tag, or sha) that should be built
      default: master
    - name: scan-image
      description: Enable the pipeline to scan the image for vulnerabilities
      default: "true"
    - name: lint-dockerfile
      description: Enable the pipeline to lint the Dockerfile for best practices
      default: "true"      
  tasks:
    - name: setup
      taskRef:
        name: ibm-setup-v2-6-13
      params:
        - name: git-url
          value: $(params.git-url)
        - name: git-revision
          value: $(params.git-revision)
        - name: scan-image
          value: $(params.scan-image)
        - name: lint-dockerfile
          value: $(params.lint-dockerfile)
    - name: test
      taskRef:
        name: ibm-java-maven-test-v2-6-13
      runAfter:
        - setup
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"

    - name: dockerfile-lint
      taskRef:
        name: ibm-dockerfile-lint-v2-6-13
      runAfter:
        - test
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: lint-dockerfile
          value: "$(tasks.setup.results.dockerfile-lint)"
          
    - name: build
      taskRef:
        name: ibm-build-tag-push-v2-6-13
      runAfter:
        - dockerfile-lint
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
    - name: deploy
      taskRef:
        name: ibm-deploy-v2-6-13
      runAfter:
        - build
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-server
          value: "$(tasks.setup.results.image-server)"
        - name: image-namespace
          value: "$(tasks.setup.results.image-namespace)"
        - name: image-repository
          value: "$(tasks.setup.results.image-repository)"
        - name: image-tag
          value: "$(tasks.setup.results.image-tag)"
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: health
      taskRef:
        name: ibm-health-check-v2-6-13
      runAfter:
        - deploy
      params:
        - name: app-namespace
          value: "$(tasks.setup.results.app-namespace)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: health-protocol
          value: "$(tasks.setup.results.health-protocol)"
        - name: health-endpoint
          value: "$(tasks.setup.results.health-endpoint)"
        - name: health-url
          value: "$(tasks.setup.results.health-url)"
        - name: health-curl
          value: "$(tasks.setup.results.health-curl)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: tag-release
      taskRef:
        name: ibm-tag-release-v2-6-13
      runAfter:
        - health
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: js-image
          value: "$(tasks.setup.results.js-image)"
    - name: img-release
      taskRef:
        name: ibm-img-release-v2-6-13
      runAfter:
        - tag-release
      params:
        - name: image-from
          value: "$(tasks.setup.results.image-url)"
        - name: image-to
          value: "$(tasks.setup.results.image-release):$(tasks.tag-release.results.tag)"
    - name: img-scan
      taskRef:
        name: ibm-img-scan-v2-6-13
      runAfter:
        - img-release
      params:
        - name: image-url
          value: $(tasks.img-release.results.image-url)
        - name: scan-trivy
          value: $(tasks.setup.results.scan-trivy)
        - name: scan-ibm
          value: $(tasks.setup.results.scan-ibm)
    - name: helm-release
      taskRef:
        name: ibm-helm-release-v2-6-13
      runAfter:
        - img-scan
      params:
        - name: git-url
          value: "$(tasks.setup.results.git-url)"
        - name: git-revision
          value: "$(tasks.setup.results.git-revision)"
        - name: source-dir
          value: "$(tasks.setup.results.source-dir)"
        - name: image-url
          value: "$(tasks.img-release.results.image-url)"
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: deploy-ingress-type
          value: "$(tasks.setup.results.deploy-ingress-type)"
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"
    - name: gitops
      taskRef:
        name: ibm-gitops-v2-6-13
      runAfter:
        - helm-release
      params:
        - name: app-name
          value: "$(tasks.setup.results.app-name)"
        - name: version
          value: "$(tasks.tag-release.results.tag)"
        - name: helm-url
          value: $(tasks.helm-release.results.helm-url)
        - name: tools-image
          value: "$(tasks.setup.results.tools-image)"

---
